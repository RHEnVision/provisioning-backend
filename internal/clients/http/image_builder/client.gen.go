// Package image_builder provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package image_builder

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// Defines values for Distributions.
const (
	Centos8  Distributions = "centos-8"
	Centos9  Distributions = "centos-9"
	Fedora35 Distributions = "fedora-35"
	Fedora36 Distributions = "fedora-36"
	Fedora37 Distributions = "fedora-37"
	Fedora38 Distributions = "fedora-38"
	Rhel8    Distributions = "rhel-8"
	Rhel84   Distributions = "rhel-84"
	Rhel85   Distributions = "rhel-85"
	Rhel86   Distributions = "rhel-86"
	Rhel87   Distributions = "rhel-87"
	Rhel9    Distributions = "rhel-9"
	Rhel90   Distributions = "rhel-90"
	Rhel91   Distributions = "rhel-91"
)

// Defines values for ImageRequestArchitecture.
const (
	ImageRequestArchitectureAarch64 ImageRequestArchitecture = "aarch64"
	ImageRequestArchitectureX8664   ImageRequestArchitecture = "x86_64"
)

// Defines values for ImageStatusStatus.
const (
	ImageStatusStatusBuilding    ImageStatusStatus = "building"
	ImageStatusStatusFailure     ImageStatusStatus = "failure"
	ImageStatusStatusPending     ImageStatusStatus = "pending"
	ImageStatusStatusRegistering ImageStatusStatus = "registering"
	ImageStatusStatusSuccess     ImageStatusStatus = "success"
	ImageStatusStatusUploading   ImageStatusStatus = "uploading"
)

// Defines values for ImageTypes.
const (
	ImageTypesAmi               ImageTypes = "ami"
	ImageTypesAws               ImageTypes = "aws"
	ImageTypesAzure             ImageTypes = "azure"
	ImageTypesEdgeCommit        ImageTypes = "edge-commit"
	ImageTypesEdgeInstaller     ImageTypes = "edge-installer"
	ImageTypesGcp               ImageTypes = "gcp"
	ImageTypesGuestImage        ImageTypes = "guest-image"
	ImageTypesImageInstaller    ImageTypes = "image-installer"
	ImageTypesRhelEdgeCommit    ImageTypes = "rhel-edge-commit"
	ImageTypesRhelEdgeInstaller ImageTypes = "rhel-edge-installer"
	ImageTypesVhd               ImageTypes = "vhd"
	ImageTypesVsphere           ImageTypes = "vsphere"
)

// Defines values for UploadStatusStatus.
const (
	UploadStatusStatusFailure UploadStatusStatus = "failure"
	UploadStatusStatusPending UploadStatusStatus = "pending"
	UploadStatusStatusRunning UploadStatusStatus = "running"
	UploadStatusStatusSuccess UploadStatusStatus = "success"
)

// Defines values for UploadTypes.
const (
	UploadTypesAws   UploadTypes = "aws"
	UploadTypesAwsS3 UploadTypes = "aws.s3"
	UploadTypesAzure UploadTypes = "azure"
	UploadTypesGcp   UploadTypes = "gcp"
)

// Defines values for GetPackagesParamsArchitecture.
const (
	GetPackagesParamsArchitectureAarch64 GetPackagesParamsArchitecture = "aarch64"
	GetPackagesParamsArchitectureX8664   GetPackagesParamsArchitecture = "x86_64"
)

// AWSEC2Clone defines model for AWSEC2Clone.
type AWSEC2Clone struct {
	// Region A region as described in
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-regions
	Region string `json:"region"`

	// ShareWithAccounts An array of AWS account IDs as described in
	// https://docs.aws.amazon.com/IAM/latest/UserGuide/console_account-alias.html
	ShareWithAccounts *[]string `json:"share_with_accounts,omitempty"`
	ShareWithSources  *[]string `json:"share_with_sources,omitempty"`
}

// AWSS3UploadRequestOptions defines model for AWSS3UploadRequestOptions.
type AWSS3UploadRequestOptions = map[string]interface{}

// AWSS3UploadStatus defines model for AWSS3UploadStatus.
type AWSS3UploadStatus struct {
	Url string `json:"url"`
}

// AWSUploadRequestOptions defines model for AWSUploadRequestOptions.
type AWSUploadRequestOptions struct {
	ShareWithAccounts *[]string `json:"share_with_accounts,omitempty"`
	ShareWithSources  *[]string `json:"share_with_sources,omitempty"`
}

// AWSUploadStatus defines model for AWSUploadStatus.
type AWSUploadStatus struct {
	Ami    string `json:"ami"`
	Region string `json:"region"`
}

// ArchitectureItem defines model for ArchitectureItem.
type ArchitectureItem struct {
	Arch       string   `json:"arch"`
	ImageTypes []string `json:"image_types"`

	// Repositories Base repositories for the given distribution and architecture.
	Repositories []Repository `json:"repositories"`
}

// Architectures defines model for Architectures.
type Architectures = []ArchitectureItem

// AzureUploadRequestOptions defines model for AzureUploadRequestOptions.
type AzureUploadRequestOptions struct {
	// ImageName Name of the created image.
	// Must begin with a letter or number, end with a letter, number or underscore, and may contain only letters, numbers, underscores, periods, or hyphens.
	// The total length is limited to 60 characters.
	ImageName *string `json:"image_name,omitempty"`

	// ResourceGroup Name of the resource group where the image should be uploaded.
	ResourceGroup string `json:"resource_group"`

	// SubscriptionId ID of subscription where the image should be uploaded.
	SubscriptionId string `json:"subscription_id"`

	// TenantId ID of the tenant where the image should be uploaded. This link explains how
	// to find it in the Azure Portal:
	// https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-how-to-find-tenant
	TenantId string `json:"tenant_id"`
}

// AzureUploadStatus defines model for AzureUploadStatus.
type AzureUploadStatus struct {
	ImageName string `json:"image_name"`
}

// CloneRequest defines model for CloneRequest.
type CloneRequest struct {
	union json.RawMessage
}

// CloneResponse defines model for CloneResponse.
type CloneResponse struct {
	Id openapi_types.UUID `json:"id"`
}

// ClonesResponse defines model for ClonesResponse.
type ClonesResponse struct {
	Data  []ClonesResponseItem `json:"data"`
	Links struct {
		First string `json:"first"`
		Last  string `json:"last"`
	} `json:"links"`
	Meta struct {
		Count int `json:"count"`
	} `json:"meta"`
}

// ClonesResponseItem defines model for ClonesResponseItem.
type ClonesResponseItem struct {
	CreatedAt string             `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Request   interface{}        `json:"request"`
}

// ComposeMetadata defines model for ComposeMetadata.
type ComposeMetadata struct {
	// OstreeCommit ID (hash) of the built commit
	OstreeCommit *string `json:"ostree_commit,omitempty"`

	// Packages Package list including NEVRA
	Packages *[]PackageMetadata `json:"packages,omitempty"`
}

// ComposeRequest defines model for ComposeRequest.
type ComposeRequest struct {
	Customizations *Customizations `json:"customizations,omitempty"`
	Distribution   Distributions   `json:"distribution"`
	ImageName      *string         `json:"image_name,omitempty"`

	// ImageRequests Array of exactly one image request. Having more image requests in one compose is currently not supported.
	ImageRequests []ImageRequest `json:"image_requests"`
}

// ComposeResponse defines model for ComposeResponse.
type ComposeResponse struct {
	Id openapi_types.UUID `json:"id"`
}

// ComposeStatus defines model for ComposeStatus.
type ComposeStatus struct {
	ImageStatus ImageStatus `json:"image_status"`
}

// ComposeStatusError defines model for ComposeStatusError.
type ComposeStatusError struct {
	Details *interface{} `json:"details,omitempty"`
	Id      int          `json:"id"`
	Reason  string       `json:"reason"`
}

// ComposesResponse defines model for ComposesResponse.
type ComposesResponse struct {
	Data  []ComposesResponseItem `json:"data"`
	Links struct {
		First string `json:"first"`
		Last  string `json:"last"`
	} `json:"links"`
	Meta struct {
		Count int `json:"count"`
	} `json:"meta"`
}

// ComposesResponseItem defines model for ComposesResponseItem.
type ComposesResponseItem struct {
	CreatedAt string             `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	ImageName *string            `json:"image_name,omitempty"`
	Request   interface{}        `json:"request"`
}

// Customizations defines model for Customizations.
type Customizations struct {
	Filesystem          *[]Filesystem `json:"filesystem,omitempty"`
	Packages            *[]string     `json:"packages,omitempty"`
	PayloadRepositories *[]Repository `json:"payload_repositories,omitempty"`
	Subscription        *Subscription `json:"subscription,omitempty"`

	// Users list of users that a customer can add, also specifying their respective groups and SSH keys
	Users *[]User `json:"users,omitempty"`
}

// DistributionItem defines model for DistributionItem.
type DistributionItem struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// Distributions defines model for Distributions.
type Distributions string

// DistributionsResponse defines model for DistributionsResponse.
type DistributionsResponse = []DistributionItem

// Filesystem defines model for Filesystem.
type Filesystem struct {
	MinSize    uint64 `json:"min_size"`
	Mountpoint string `json:"mountpoint"`
}

// GCPUploadRequestOptions defines model for GCPUploadRequestOptions.
type GCPUploadRequestOptions struct {
	// ShareWithAccounts List of valid Google accounts to share the imported Compute Node image with.
	// Each string must contain a specifier of the account type. Valid formats are:
	//   - 'user:{emailid}': An email address that represents a specific
	//     Google account. For example, 'alice@example.com'.
	//   - 'serviceAccount:{emailid}': An email address that represents a
	//     service account. For example, 'my-other-app@appspot.gserviceaccount.com'.
	//   - 'group:{emailid}': An email address that represents a Google group.
	//     For example, 'admins@example.com'.
	//   - 'domain:{domain}': The G Suite domain (primary) that represents all
	//     the users of that domain. For example, 'google.com' or 'example.com'.
	//     If not specified, the imported Compute Node image is not shared with any
	//     account.
	ShareWithAccounts []string `json:"share_with_accounts"`
}

// GCPUploadStatus defines model for GCPUploadStatus.
type GCPUploadStatus struct {
	ImageName string `json:"image_name"`
	ProjectId string `json:"project_id"`
}

// HTTPError defines model for HTTPError.
type HTTPError struct {
	Detail string `json:"detail"`
	Title  string `json:"title"`
}

// HTTPErrorList defines model for HTTPErrorList.
type HTTPErrorList struct {
	Errors []HTTPError `json:"errors"`
}

// ImageRequest defines model for ImageRequest.
type ImageRequest struct {
	// Architecture CPU architecture of the image, x86_64 and aarch64 are currently supported.
	Architecture  ImageRequestArchitecture `json:"architecture"`
	ImageType     ImageTypes               `json:"image_type"`
	Ostree        *OSTree                  `json:"ostree,omitempty"`
	UploadRequest UploadRequest            `json:"upload_request"`
}

// ImageRequestArchitecture CPU architecture of the image, x86_64 and aarch64 are currently supported.
type ImageRequestArchitecture string

// ImageStatus defines model for ImageStatus.
type ImageStatus struct {
	Error        *ComposeStatusError `json:"error,omitempty"`
	Status       ImageStatusStatus   `json:"status"`
	UploadStatus *UploadStatus       `json:"upload_status,omitempty"`
}

// ImageStatusStatus defines model for ImageStatus.Status.
type ImageStatusStatus string

// ImageTypes defines model for ImageTypes.
type ImageTypes string

// OSTree defines model for OSTree.
type OSTree struct {
	// Contenturl A URL which, if set, is used for fetching content. Implies that `url` is set as well,
	// which will be used for metadata only.
	Contenturl *string `json:"contenturl,omitempty"`

	// Parent Can be either a commit (example: 02604b2da6e954bd34b8b82a835e5a77d2b60ffa), or a branch-like reference (example: rhel/8/x86_64/edge)
	Parent *string `json:"parent,omitempty"`
	Ref    *string `json:"ref,omitempty"`

	// Rhsm Determines whether a valid subscription manager (candlepin) identity is required to
	// access this repository. Consumer certificates will be used as client certificates when
	// fetching metadata and content.
	Rhsm *bool   `json:"rhsm,omitempty"`
	Url  *string `json:"url,omitempty"`
}

// Package defines model for Package.
type Package struct {
	Name    string `json:"name"`
	Summary string `json:"summary"`
}

// PackageMetadata defines model for PackageMetadata.
type PackageMetadata struct {
	Arch      string  `json:"arch"`
	Epoch     *string `json:"epoch,omitempty"`
	Name      string  `json:"name"`
	Release   string  `json:"release"`
	Sigmd5    string  `json:"sigmd5"`
	Signature *string `json:"signature,omitempty"`
	Type      string  `json:"type"`
	Version   string  `json:"version"`
}

// PackagesResponse defines model for PackagesResponse.
type PackagesResponse struct {
	Data  []Package `json:"data"`
	Links struct {
		First string `json:"first"`
		Last  string `json:"last"`
	} `json:"links"`
	Meta struct {
		Count int `json:"count"`
	} `json:"meta"`
}

// Readiness defines model for Readiness.
type Readiness struct {
	Readiness string `json:"readiness"`
}

// Repository defines model for Repository.
type Repository struct {
	Baseurl    *string `json:"baseurl,omitempty"`
	CheckGpg   *bool   `json:"check_gpg,omitempty"`
	Gpgkey     *string `json:"gpgkey,omitempty"`
	IgnoreSsl  *bool   `json:"ignore_ssl,omitempty"`
	Metalink   *string `json:"metalink,omitempty"`
	Mirrorlist *string `json:"mirrorlist,omitempty"`
	Rhsm       bool    `json:"rhsm"`
}

// Subscription defines model for Subscription.
type Subscription struct {
	ActivationKey string `json:"activation-key"`
	BaseUrl       string `json:"base-url"`
	Insights      bool   `json:"insights"`
	Organization  int    `json:"organization"`

	// Rhc Optional flag to use rhc to register the system, which also always enables Insights.
	Rhc       *bool  `json:"rhc,omitempty"`
	ServerUrl string `json:"server-url"`
}

// UploadRequest defines model for UploadRequest.
type UploadRequest struct {
	Options UploadRequest_Options `json:"options"`
	Type    UploadTypes           `json:"type"`
}

// UploadRequest_Options defines model for UploadRequest.Options.
type UploadRequest_Options struct {
	union json.RawMessage
}

// UploadStatus defines model for UploadStatus.
type UploadStatus struct {
	Options UploadStatus_Options `json:"options"`
	Status  UploadStatusStatus   `json:"status"`
	Type    UploadTypes          `json:"type"`
}

// UploadStatus_Options defines model for UploadStatus.Options.
type UploadStatus_Options struct {
	union json.RawMessage
}

// UploadStatusStatus defines model for UploadStatus.Status.
type UploadStatusStatus string

// UploadTypes defines model for UploadTypes.
type UploadTypes string

// User defines model for User.
type User struct {
	Name   string `json:"name"`
	SshKey string `json:"ssh_key"`
}

// Version defines model for Version.
type Version struct {
	Version string `json:"version"`
}

// GetComposesParams defines parameters for GetComposes.
type GetComposesParams struct {
	// Limit max amount of composes, default 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset composes page offset, default 0
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetComposeClonesParams defines parameters for GetComposeClones.
type GetComposeClonesParams struct {
	// Limit max amount of clones, default 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset clones page offset, default 0
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetPackagesParams defines parameters for GetPackages.
type GetPackagesParams struct {
	// Distribution distribution to look up packages for
	Distribution Distributions `form:"distribution" json:"distribution"`

	// Architecture architecture to look up packages for
	Architecture GetPackagesParamsArchitecture `form:"architecture" json:"architecture"`

	// Search packages to look for
	Search string `form:"search" json:"search"`

	// Limit max amount of packages, default 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset packages page offset, default 0
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetPackagesParamsArchitecture defines parameters for GetPackages.
type GetPackagesParamsArchitecture string

// ComposeImageJSONRequestBody defines body for ComposeImage for application/json ContentType.
type ComposeImageJSONRequestBody = ComposeRequest

// CloneComposeJSONRequestBody defines body for CloneCompose for application/json ContentType.
type CloneComposeJSONRequestBody = CloneRequest

// AsAWSEC2Clone returns the union data inside the CloneRequest as a AWSEC2Clone
func (t CloneRequest) AsAWSEC2Clone() (AWSEC2Clone, error) {
	var body AWSEC2Clone
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSEC2Clone overwrites any union data inside the CloneRequest as the provided AWSEC2Clone
func (t *CloneRequest) FromAWSEC2Clone(v AWSEC2Clone) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSEC2Clone performs a merge with any union data inside the CloneRequest, using the provided AWSEC2Clone
func (t *CloneRequest) MergeAWSEC2Clone(v AWSEC2Clone) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CloneRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CloneRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSUploadRequestOptions returns the union data inside the UploadRequest_Options as a AWSUploadRequestOptions
func (t UploadRequest_Options) AsAWSUploadRequestOptions() (AWSUploadRequestOptions, error) {
	var body AWSUploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSUploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided AWSUploadRequestOptions
func (t *UploadRequest_Options) FromAWSUploadRequestOptions(v AWSUploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSUploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided AWSUploadRequestOptions
func (t *UploadRequest_Options) MergeAWSUploadRequestOptions(v AWSUploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAWSS3UploadRequestOptions returns the union data inside the UploadRequest_Options as a AWSS3UploadRequestOptions
func (t UploadRequest_Options) AsAWSS3UploadRequestOptions() (AWSS3UploadRequestOptions, error) {
	var body AWSS3UploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSS3UploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided AWSS3UploadRequestOptions
func (t *UploadRequest_Options) FromAWSS3UploadRequestOptions(v AWSS3UploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSS3UploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided AWSS3UploadRequestOptions
func (t *UploadRequest_Options) MergeAWSS3UploadRequestOptions(v AWSS3UploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGCPUploadRequestOptions returns the union data inside the UploadRequest_Options as a GCPUploadRequestOptions
func (t UploadRequest_Options) AsGCPUploadRequestOptions() (GCPUploadRequestOptions, error) {
	var body GCPUploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPUploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided GCPUploadRequestOptions
func (t *UploadRequest_Options) FromGCPUploadRequestOptions(v GCPUploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPUploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided GCPUploadRequestOptions
func (t *UploadRequest_Options) MergeGCPUploadRequestOptions(v GCPUploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureUploadRequestOptions returns the union data inside the UploadRequest_Options as a AzureUploadRequestOptions
func (t UploadRequest_Options) AsAzureUploadRequestOptions() (AzureUploadRequestOptions, error) {
	var body AzureUploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureUploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided AzureUploadRequestOptions
func (t *UploadRequest_Options) FromAzureUploadRequestOptions(v AzureUploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureUploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided AzureUploadRequestOptions
func (t *UploadRequest_Options) MergeAzureUploadRequestOptions(v AzureUploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UploadRequest_Options) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadRequest_Options) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSUploadStatus returns the union data inside the UploadStatus_Options as a AWSUploadStatus
func (t UploadStatus_Options) AsAWSUploadStatus() (AWSUploadStatus, error) {
	var body AWSUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSUploadStatus overwrites any union data inside the UploadStatus_Options as the provided AWSUploadStatus
func (t *UploadStatus_Options) FromAWSUploadStatus(v AWSUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AWSUploadStatus
func (t *UploadStatus_Options) MergeAWSUploadStatus(v AWSUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAWSS3UploadStatus returns the union data inside the UploadStatus_Options as a AWSS3UploadStatus
func (t UploadStatus_Options) AsAWSS3UploadStatus() (AWSS3UploadStatus, error) {
	var body AWSS3UploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSS3UploadStatus overwrites any union data inside the UploadStatus_Options as the provided AWSS3UploadStatus
func (t *UploadStatus_Options) FromAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSS3UploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AWSS3UploadStatus
func (t *UploadStatus_Options) MergeAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGCPUploadStatus returns the union data inside the UploadStatus_Options as a GCPUploadStatus
func (t UploadStatus_Options) AsGCPUploadStatus() (GCPUploadStatus, error) {
	var body GCPUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPUploadStatus overwrites any union data inside the UploadStatus_Options as the provided GCPUploadStatus
func (t *UploadStatus_Options) FromGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided GCPUploadStatus
func (t *UploadStatus_Options) MergeGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureUploadStatus returns the union data inside the UploadStatus_Options as a AzureUploadStatus
func (t UploadStatus_Options) AsAzureUploadStatus() (AzureUploadStatus, error) {
	var body AzureUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureUploadStatus overwrites any union data inside the UploadStatus_Options as the provided AzureUploadStatus
func (t *UploadStatus_Options) FromAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AzureUploadStatus
func (t *UploadStatus_Options) MergeAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UploadStatus_Options) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadStatus_Options) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetArchitectures request
	GetArchitectures(ctx context.Context, distribution string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloneStatus request
	GetCloneStatus(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ComposeImage request with any body
	ComposeImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ComposeImage(ctx context.Context, body ComposeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComposes request
	GetComposes(ctx context.Context, params *GetComposesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComposeStatus request
	GetComposeStatus(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneCompose request with any body
	CloneComposeWithBody(ctx context.Context, composeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CloneCompose(ctx context.Context, composeId openapi_types.UUID, body CloneComposeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComposeClones request
	GetComposeClones(ctx context.Context, composeId openapi_types.UUID, params *GetComposeClonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComposeMetadata request
	GetComposeMetadata(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDistributions request
	GetDistributions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiJson request
	GetOpenapiJson(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackages request
	GetPackages(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReadiness request
	GetReadiness(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersion request
	GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetArchitectures(ctx context.Context, distribution string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchitecturesRequest(c.Server, distribution)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloneStatus(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloneStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComposeImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComposeImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ComposeImage(ctx context.Context, body ComposeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewComposeImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComposes(ctx context.Context, params *GetComposesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComposesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComposeStatus(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComposeStatusRequest(c.Server, composeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneComposeWithBody(ctx context.Context, composeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneComposeRequestWithBody(c.Server, composeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneCompose(ctx context.Context, composeId openapi_types.UUID, body CloneComposeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneComposeRequest(c.Server, composeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComposeClones(ctx context.Context, composeId openapi_types.UUID, params *GetComposeClonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComposeClonesRequest(c.Server, composeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComposeMetadata(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComposeMetadataRequest(c.Server, composeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDistributions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDistributionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiJson(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiJsonRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackages(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReadiness(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReadinessRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetArchitecturesRequest generates requests for GetArchitectures
func NewGetArchitecturesRequest(server string, distribution string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "distribution", runtime.ParamLocationPath, distribution)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/architectures/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloneStatusRequest generates requests for GetCloneStatus
func NewGetCloneStatusRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewComposeImageRequest calls the generic ComposeImage builder with application/json body
func NewComposeImageRequest(server string, body ComposeImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewComposeImageRequestWithBody(server, "application/json", bodyReader)
}

// NewComposeImageRequestWithBody generates requests for ComposeImage with any type of body
func NewComposeImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compose")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetComposesRequest generates requests for GetComposes
func NewGetComposesRequest(server string, params *GetComposesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/composes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComposeStatusRequest generates requests for GetComposeStatus
func NewGetComposeStatusRequest(server string, composeId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "composeId", runtime.ParamLocationPath, composeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/composes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCloneComposeRequest calls the generic CloneCompose builder with application/json body
func NewCloneComposeRequest(server string, composeId openapi_types.UUID, body CloneComposeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloneComposeRequestWithBody(server, composeId, "application/json", bodyReader)
}

// NewCloneComposeRequestWithBody generates requests for CloneCompose with any type of body
func NewCloneComposeRequestWithBody(server string, composeId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "composeId", runtime.ParamLocationPath, composeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/composes/%s/clone", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetComposeClonesRequest generates requests for GetComposeClones
func NewGetComposeClonesRequest(server string, composeId openapi_types.UUID, params *GetComposeClonesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "composeId", runtime.ParamLocationPath, composeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/composes/%s/clones", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComposeMetadataRequest generates requests for GetComposeMetadata
func NewGetComposeMetadataRequest(server string, composeId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "composeId", runtime.ParamLocationPath, composeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/composes/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDistributionsRequest generates requests for GetDistributions
func NewGetDistributionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/distributions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiJsonRequest generates requests for GetOpenapiJson
func NewGetOpenapiJsonRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackagesRequest generates requests for GetPackages
func NewGetPackagesRequest(server string, params *GetPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "distribution", runtime.ParamLocationQuery, params.Distribution); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architecture", runtime.ParamLocationQuery, params.Architecture); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, params.Search); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReadinessRequest generates requests for GetReadiness
func NewGetReadinessRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionRequest generates requests for GetVersion
func NewGetVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetArchitectures request
	GetArchitecturesWithResponse(ctx context.Context, distribution string, reqEditors ...RequestEditorFn) (*GetArchitecturesResponse, error)

	// GetCloneStatus request
	GetCloneStatusWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCloneStatusResponse, error)

	// ComposeImage request with any body
	ComposeImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComposeImageResponse, error)

	ComposeImageWithResponse(ctx context.Context, body ComposeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*ComposeImageResponse, error)

	// GetComposes request
	GetComposesWithResponse(ctx context.Context, params *GetComposesParams, reqEditors ...RequestEditorFn) (*GetComposesResponse, error)

	// GetComposeStatus request
	GetComposeStatusWithResponse(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetComposeStatusResponse, error)

	// CloneCompose request with any body
	CloneComposeWithBodyWithResponse(ctx context.Context, composeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneComposeResponse, error)

	CloneComposeWithResponse(ctx context.Context, composeId openapi_types.UUID, body CloneComposeJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneComposeResponse, error)

	// GetComposeClones request
	GetComposeClonesWithResponse(ctx context.Context, composeId openapi_types.UUID, params *GetComposeClonesParams, reqEditors ...RequestEditorFn) (*GetComposeClonesResponse, error)

	// GetComposeMetadata request
	GetComposeMetadataWithResponse(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetComposeMetadataResponse, error)

	// GetDistributions request
	GetDistributionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDistributionsResponse, error)

	// GetOpenapiJson request
	GetOpenapiJsonWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiJsonResponse, error)

	// GetPackages request
	GetPackagesWithResponse(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error)

	// GetReadiness request
	GetReadinessWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadinessResponse, error)

	// GetVersion request
	GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error)
}

type GetArchitecturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Architectures
}

// Status returns HTTPResponse.Status
func (r GetArchitecturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchitecturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloneStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadStatus
}

// Status returns HTTPResponse.Status
func (r GetCloneStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloneStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ComposeImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ComposeResponse
	JSON400      *HTTPErrorList
}

// Status returns HTTPResponse.Status
func (r ComposeImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ComposeImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComposesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComposesResponse
}

// Status returns HTTPResponse.Status
func (r GetComposesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComposesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComposeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComposeStatus
}

// Status returns HTTPResponse.Status
func (r GetComposeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComposeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneComposeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CloneResponse
}

// Status returns HTTPResponse.Status
func (r CloneComposeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneComposeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComposeClonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClonesResponse
}

// Status returns HTTPResponse.Status
func (r GetComposeClonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComposeClonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComposeMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComposeMetadata
}

// Status returns HTTPResponse.Status
func (r GetComposeMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComposeMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDistributionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DistributionsResponse
}

// Status returns HTTPResponse.Status
func (r GetDistributionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDistributionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiJsonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetOpenapiJsonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiJsonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackagesResponse
}

// Status returns HTTPResponse.Status
func (r GetPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReadinessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Readiness
}

// Status returns HTTPResponse.Status
func (r GetReadinessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReadinessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
}

// Status returns HTTPResponse.Status
func (r GetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetArchitecturesWithResponse request returning *GetArchitecturesResponse
func (c *ClientWithResponses) GetArchitecturesWithResponse(ctx context.Context, distribution string, reqEditors ...RequestEditorFn) (*GetArchitecturesResponse, error) {
	rsp, err := c.GetArchitectures(ctx, distribution, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchitecturesResponse(rsp)
}

// GetCloneStatusWithResponse request returning *GetCloneStatusResponse
func (c *ClientWithResponses) GetCloneStatusWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCloneStatusResponse, error) {
	rsp, err := c.GetCloneStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloneStatusResponse(rsp)
}

// ComposeImageWithBodyWithResponse request with arbitrary body returning *ComposeImageResponse
func (c *ClientWithResponses) ComposeImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ComposeImageResponse, error) {
	rsp, err := c.ComposeImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComposeImageResponse(rsp)
}

func (c *ClientWithResponses) ComposeImageWithResponse(ctx context.Context, body ComposeImageJSONRequestBody, reqEditors ...RequestEditorFn) (*ComposeImageResponse, error) {
	rsp, err := c.ComposeImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseComposeImageResponse(rsp)
}

// GetComposesWithResponse request returning *GetComposesResponse
func (c *ClientWithResponses) GetComposesWithResponse(ctx context.Context, params *GetComposesParams, reqEditors ...RequestEditorFn) (*GetComposesResponse, error) {
	rsp, err := c.GetComposes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComposesResponse(rsp)
}

// GetComposeStatusWithResponse request returning *GetComposeStatusResponse
func (c *ClientWithResponses) GetComposeStatusWithResponse(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetComposeStatusResponse, error) {
	rsp, err := c.GetComposeStatus(ctx, composeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComposeStatusResponse(rsp)
}

// CloneComposeWithBodyWithResponse request with arbitrary body returning *CloneComposeResponse
func (c *ClientWithResponses) CloneComposeWithBodyWithResponse(ctx context.Context, composeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneComposeResponse, error) {
	rsp, err := c.CloneComposeWithBody(ctx, composeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneComposeResponse(rsp)
}

func (c *ClientWithResponses) CloneComposeWithResponse(ctx context.Context, composeId openapi_types.UUID, body CloneComposeJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneComposeResponse, error) {
	rsp, err := c.CloneCompose(ctx, composeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneComposeResponse(rsp)
}

// GetComposeClonesWithResponse request returning *GetComposeClonesResponse
func (c *ClientWithResponses) GetComposeClonesWithResponse(ctx context.Context, composeId openapi_types.UUID, params *GetComposeClonesParams, reqEditors ...RequestEditorFn) (*GetComposeClonesResponse, error) {
	rsp, err := c.GetComposeClones(ctx, composeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComposeClonesResponse(rsp)
}

// GetComposeMetadataWithResponse request returning *GetComposeMetadataResponse
func (c *ClientWithResponses) GetComposeMetadataWithResponse(ctx context.Context, composeId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetComposeMetadataResponse, error) {
	rsp, err := c.GetComposeMetadata(ctx, composeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComposeMetadataResponse(rsp)
}

// GetDistributionsWithResponse request returning *GetDistributionsResponse
func (c *ClientWithResponses) GetDistributionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDistributionsResponse, error) {
	rsp, err := c.GetDistributions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDistributionsResponse(rsp)
}

// GetOpenapiJsonWithResponse request returning *GetOpenapiJsonResponse
func (c *ClientWithResponses) GetOpenapiJsonWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiJsonResponse, error) {
	rsp, err := c.GetOpenapiJson(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiJsonResponse(rsp)
}

// GetPackagesWithResponse request returning *GetPackagesResponse
func (c *ClientWithResponses) GetPackagesWithResponse(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error) {
	rsp, err := c.GetPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagesResponse(rsp)
}

// GetReadinessWithResponse request returning *GetReadinessResponse
func (c *ClientWithResponses) GetReadinessWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadinessResponse, error) {
	rsp, err := c.GetReadiness(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReadinessResponse(rsp)
}

// GetVersionWithResponse request returning *GetVersionResponse
func (c *ClientWithResponses) GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error) {
	rsp, err := c.GetVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionResponse(rsp)
}

// ParseGetArchitecturesResponse parses an HTTP response from a GetArchitecturesWithResponse call
func ParseGetArchitecturesResponse(rsp *http.Response) (*GetArchitecturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchitecturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Architectures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCloneStatusResponse parses an HTTP response from a GetCloneStatusWithResponse call
func ParseGetCloneStatusResponse(rsp *http.Response) (*GetCloneStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloneStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseComposeImageResponse parses an HTTP response from a ComposeImageWithResponse call
func ParseComposeImageResponse(rsp *http.Response) (*ComposeImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ComposeImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ComposeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest HTTPErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetComposesResponse parses an HTTP response from a GetComposesWithResponse call
func ParseGetComposesResponse(rsp *http.Response) (*GetComposesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComposesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComposesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetComposeStatusResponse parses an HTTP response from a GetComposeStatusWithResponse call
func ParseGetComposeStatusResponse(rsp *http.Response) (*GetComposeStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComposeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComposeStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCloneComposeResponse parses an HTTP response from a CloneComposeWithResponse call
func ParseCloneComposeResponse(rsp *http.Response) (*CloneComposeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneComposeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CloneResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetComposeClonesResponse parses an HTTP response from a GetComposeClonesWithResponse call
func ParseGetComposeClonesResponse(rsp *http.Response) (*GetComposeClonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComposeClonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClonesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetComposeMetadataResponse parses an HTTP response from a GetComposeMetadataWithResponse call
func ParseGetComposeMetadataResponse(rsp *http.Response) (*GetComposeMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComposeMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComposeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDistributionsResponse parses an HTTP response from a GetDistributionsWithResponse call
func ParseGetDistributionsResponse(rsp *http.Response) (*GetDistributionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDistributionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DistributionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOpenapiJsonResponse parses an HTTP response from a GetOpenapiJsonWithResponse call
func ParseGetOpenapiJsonResponse(rsp *http.Response) (*GetOpenapiJsonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiJsonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPackagesResponse parses an HTTP response from a GetPackagesWithResponse call
func ParseGetPackagesResponse(rsp *http.Response) (*GetPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReadinessResponse parses an HTTP response from a GetReadinessWithResponse call
func ParseGetReadinessResponse(rsp *http.Response) (*GetReadinessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReadinessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Readiness
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVersionResponse parses an HTTP response from a GetVersionWithResponse call
func ParseGetVersionResponse(rsp *http.Response) (*GetVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
