// Package sources provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package sources

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	Basic_authScopes                  = "basic_auth.Scopes"
	X_rh_identityScopes               = "x_rh_identity.Scopes"
	X_rh_sources_account_numberScopes = "x_rh_sources_account_number.Scopes"
	X_rh_sources_org_idScopes         = "x_rh_sources_org_id.Scopes"
)

// Defines values for ApplicationAvailabilityStatus.
const (
	ApplicationAvailabilityStatusAvailable          ApplicationAvailabilityStatus = "available"
	ApplicationAvailabilityStatusInProgress         ApplicationAvailabilityStatus = "in_progress"
	ApplicationAvailabilityStatusPartiallyAvailable ApplicationAvailabilityStatus = "partially_available"
	ApplicationAvailabilityStatusUnavailable        ApplicationAvailabilityStatus = "unavailable"
)

// Defines values for ApplicationUpdateAvailabilityStatus.
const (
	ApplicationUpdateAvailabilityStatusAvailable          ApplicationUpdateAvailabilityStatus = "available"
	ApplicationUpdateAvailabilityStatusInProgress         ApplicationUpdateAvailabilityStatus = "in_progress"
	ApplicationUpdateAvailabilityStatusPartiallyAvailable ApplicationUpdateAvailabilityStatus = "partially_available"
	ApplicationUpdateAvailabilityStatusUnavailable        ApplicationUpdateAvailabilityStatus = "unavailable"
)

// Defines values for AuthenticationReadAuthtype.
const (
	AuthenticationReadAuthtypeAccessKeySecretKey                   AuthenticationReadAuthtype = "access_key_secret_key"
	AuthenticationReadAuthtypeApiTokenAccountId                    AuthenticationReadAuthtype = "api_token_account_id"
	AuthenticationReadAuthtypeArn                                  AuthenticationReadAuthtype = "arn"
	AuthenticationReadAuthtypeBitbucketAppPassword                 AuthenticationReadAuthtype = "bitbucket-app-password"
	AuthenticationReadAuthtypeCloudMeterArn                        AuthenticationReadAuthtype = "cloud-meter-arn"
	AuthenticationReadAuthtypeDockerAccessToken                    AuthenticationReadAuthtype = "docker-access-token"
	AuthenticationReadAuthtypeGithubPersonalAccessToken            AuthenticationReadAuthtype = "github-personal-access-token"
	AuthenticationReadAuthtypeGitlabPersonalAccessToken            AuthenticationReadAuthtype = "gitlab-personal-access-token"
	AuthenticationReadAuthtypeLighthouseSubscriptionId             AuthenticationReadAuthtype = "lighthouse_subscription_id"
	AuthenticationReadAuthtypeMarketplaceToken                     AuthenticationReadAuthtype = "marketplace-token"
	AuthenticationReadAuthtypeOcid                                 AuthenticationReadAuthtype = "ocid"
	AuthenticationReadAuthtypeProjectIdServiceAccountJson          AuthenticationReadAuthtype = "project_id_service_account_json"
	AuthenticationReadAuthtypeProvisioningArn                      AuthenticationReadAuthtype = "provisioning-arn"
	AuthenticationReadAuthtypeProvisioningLighthouseSubscriptionId AuthenticationReadAuthtype = "provisioning_lighthouse_subscription_id"
	AuthenticationReadAuthtypeProvisioningProjectId                AuthenticationReadAuthtype = "provisioning_project_id"
	AuthenticationReadAuthtypeQuayEncryptedPassword                AuthenticationReadAuthtype = "quay-encrypted-password"
	AuthenticationReadAuthtypeReceptorNode                         AuthenticationReadAuthtype = "receptor_node"
	AuthenticationReadAuthtypeTenantIdClientIdClientSecret         AuthenticationReadAuthtype = "tenant_id_client_id_client_secret"
	AuthenticationReadAuthtypeToken                                AuthenticationReadAuthtype = "token"
	AuthenticationReadAuthtypeUsernamePassword                     AuthenticationReadAuthtype = "username_password"
)

// Defines values for AuthenticationReadResourceType.
const (
	AuthenticationReadResourceTypeApplication    AuthenticationReadResourceType = "Application"
	AuthenticationReadResourceTypeAuthentication AuthenticationReadResourceType = "Authentication"
	AuthenticationReadResourceTypeEndpoint       AuthenticationReadResourceType = "Endpoint"
	AuthenticationReadResourceTypeSource         AuthenticationReadResourceType = "Source"
)

// Defines values for BulkCreatePayloadAuthenticationsAuthtype.
const (
	BulkCreatePayloadAuthenticationsAuthtypeAccessKeySecretKey                   BulkCreatePayloadAuthenticationsAuthtype = "access_key_secret_key"
	BulkCreatePayloadAuthenticationsAuthtypeApiTokenAccountId                    BulkCreatePayloadAuthenticationsAuthtype = "api_token_account_id"
	BulkCreatePayloadAuthenticationsAuthtypeArn                                  BulkCreatePayloadAuthenticationsAuthtype = "arn"
	BulkCreatePayloadAuthenticationsAuthtypeBitbucketAppPassword                 BulkCreatePayloadAuthenticationsAuthtype = "bitbucket-app-password"
	BulkCreatePayloadAuthenticationsAuthtypeCloudMeterArn                        BulkCreatePayloadAuthenticationsAuthtype = "cloud-meter-arn"
	BulkCreatePayloadAuthenticationsAuthtypeDockerAccessToken                    BulkCreatePayloadAuthenticationsAuthtype = "docker-access-token"
	BulkCreatePayloadAuthenticationsAuthtypeGithubPersonalAccessToken            BulkCreatePayloadAuthenticationsAuthtype = "github-personal-access-token"
	BulkCreatePayloadAuthenticationsAuthtypeGitlabPersonalAccessToken            BulkCreatePayloadAuthenticationsAuthtype = "gitlab-personal-access-token"
	BulkCreatePayloadAuthenticationsAuthtypeLighthouseSubscriptionId             BulkCreatePayloadAuthenticationsAuthtype = "lighthouse_subscription_id"
	BulkCreatePayloadAuthenticationsAuthtypeMarketplaceToken                     BulkCreatePayloadAuthenticationsAuthtype = "marketplace-token"
	BulkCreatePayloadAuthenticationsAuthtypeOcid                                 BulkCreatePayloadAuthenticationsAuthtype = "ocid"
	BulkCreatePayloadAuthenticationsAuthtypeProjectIdServiceAccountJson          BulkCreatePayloadAuthenticationsAuthtype = "project_id_service_account_json"
	BulkCreatePayloadAuthenticationsAuthtypeProvisioningArn                      BulkCreatePayloadAuthenticationsAuthtype = "provisioning-arn"
	BulkCreatePayloadAuthenticationsAuthtypeProvisioningLighthouseSubscriptionId BulkCreatePayloadAuthenticationsAuthtype = "provisioning_lighthouse_subscription_id"
	BulkCreatePayloadAuthenticationsAuthtypeProvisioningProjectId                BulkCreatePayloadAuthenticationsAuthtype = "provisioning_project_id"
	BulkCreatePayloadAuthenticationsAuthtypeQuayEncryptedPassword                BulkCreatePayloadAuthenticationsAuthtype = "quay-encrypted-password"
	BulkCreatePayloadAuthenticationsAuthtypeReceptorNode                         BulkCreatePayloadAuthenticationsAuthtype = "receptor_node"
	BulkCreatePayloadAuthenticationsAuthtypeTenantIdClientIdClientSecret         BulkCreatePayloadAuthenticationsAuthtype = "tenant_id_client_id_client_secret"
	BulkCreatePayloadAuthenticationsAuthtypeToken                                BulkCreatePayloadAuthenticationsAuthtype = "token"
	BulkCreatePayloadAuthenticationsAuthtypeUsernamePassword                     BulkCreatePayloadAuthenticationsAuthtype = "username_password"
)

// Defines values for BulkCreatePayloadAuthenticationsResourceType.
const (
	BulkCreatePayloadAuthenticationsResourceTypeApplication BulkCreatePayloadAuthenticationsResourceType = "Application"
	BulkCreatePayloadAuthenticationsResourceTypeEndpoint    BulkCreatePayloadAuthenticationsResourceType = "Endpoint"
	BulkCreatePayloadAuthenticationsResourceTypeSource      BulkCreatePayloadAuthenticationsResourceType = "Source"
)

// Defines values for BulkCreatePayloadSourcesAppCreationWorkflow.
const (
	BulkCreatePayloadSourcesAppCreationWorkflowAccountAuthorization BulkCreatePayloadSourcesAppCreationWorkflow = "account_authorization"
	BulkCreatePayloadSourcesAppCreationWorkflowManualConfiguration  BulkCreatePayloadSourcesAppCreationWorkflow = "manual_configuration"
)

// Defines values for BulkCreatePayloadSourcesSourceTypeName.
const (
	Amazon                    BulkCreatePayloadSourcesSourceTypeName = "amazon"
	Azure                     BulkCreatePayloadSourcesSourceTypeName = "azure"
	Bitbucket                 BulkCreatePayloadSourcesSourceTypeName = "bitbucket"
	Dockerhub                 BulkCreatePayloadSourcesSourceTypeName = "dockerhub"
	Github                    BulkCreatePayloadSourcesSourceTypeName = "github"
	Gitlab                    BulkCreatePayloadSourcesSourceTypeName = "gitlab"
	Google                    BulkCreatePayloadSourcesSourceTypeName = "google"
	Ibm                       BulkCreatePayloadSourcesSourceTypeName = "ibm"
	Openshift                 BulkCreatePayloadSourcesSourceTypeName = "openshift"
	OracleCloudInfrastructure BulkCreatePayloadSourcesSourceTypeName = "oracle-cloud-infrastructure"
	Quay                      BulkCreatePayloadSourcesSourceTypeName = "quay"
	RhMarketplace             BulkCreatePayloadSourcesSourceTypeName = "rh-marketplace"
	Satellite                 BulkCreatePayloadSourcesSourceTypeName = "satellite"
)

// Defines values for EndpointAvailabilityStatus.
const (
	EndpointAvailabilityStatusAvailable   EndpointAvailabilityStatus = "available"
	EndpointAvailabilityStatusEmpty       EndpointAvailabilityStatus = ""
	EndpointAvailabilityStatusInProgress  EndpointAvailabilityStatus = "in_progress"
	EndpointAvailabilityStatusUnavailable EndpointAvailabilityStatus = "unavailable"
)

// Defines values for EndpointReadAvailabilityStatus.
const (
	EndpointReadAvailabilityStatusAvailable   EndpointReadAvailabilityStatus = "available"
	EndpointReadAvailabilityStatusEmpty       EndpointReadAvailabilityStatus = ""
	EndpointReadAvailabilityStatusInProgress  EndpointReadAvailabilityStatus = "in_progress"
	EndpointReadAvailabilityStatusUnavailable EndpointReadAvailabilityStatus = "unavailable"
)

// Defines values for RhcConnectionReadAvailabilityStatus.
const (
	RhcConnectionReadAvailabilityStatusAvailable          RhcConnectionReadAvailabilityStatus = "available"
	RhcConnectionReadAvailabilityStatusInProgress         RhcConnectionReadAvailabilityStatus = "in_progress"
	RhcConnectionReadAvailabilityStatusPartiallyAvailable RhcConnectionReadAvailabilityStatus = "partially_available"
	RhcConnectionReadAvailabilityStatusUnavailable        RhcConnectionReadAvailabilityStatus = "unavailable"
)

// Defines values for SourceAppCreationWorkflow.
const (
	SourceAppCreationWorkflowAccountAuthorization SourceAppCreationWorkflow = "account_authorization"
	SourceAppCreationWorkflowManualConfiguration  SourceAppCreationWorkflow = "manual_configuration"
)

// Defines values for SourceAvailabilityStatus.
const (
	SourceAvailabilityStatusAvailable          SourceAvailabilityStatus = "available"
	SourceAvailabilityStatusInProgress         SourceAvailabilityStatus = "in_progress"
	SourceAvailabilityStatusPartiallyAvailable SourceAvailabilityStatus = "partially_available"
	SourceAvailabilityStatusUnavailable        SourceAvailabilityStatus = "unavailable"
)

// Defines values for SourceCreateAppCreationWorkflow.
const (
	AccountAuthorization SourceCreateAppCreationWorkflow = "account_authorization"
	ManualConfiguration  SourceCreateAppCreationWorkflow = "manual_configuration"
)

// Defines values for SourceCreateAvailabilityStatus.
const (
	SourceCreateAvailabilityStatusAvailable          SourceCreateAvailabilityStatus = "available"
	SourceCreateAvailabilityStatusInProgress         SourceCreateAvailabilityStatus = "in_progress"
	SourceCreateAvailabilityStatusPartiallyAvailable SourceCreateAvailabilityStatus = "partially_available"
	SourceCreateAvailabilityStatusUnavailable        SourceCreateAvailabilityStatus = "unavailable"
)

// Defines values for SourceEditAvailabilityStatus.
const (
	SourceEditAvailabilityStatusAvailable          SourceEditAvailabilityStatus = "available"
	SourceEditAvailabilityStatusInProgress         SourceEditAvailabilityStatus = "in_progress"
	SourceEditAvailabilityStatusPartiallyAvailable SourceEditAvailabilityStatus = "partially_available"
	SourceEditAvailabilityStatusUnavailable        SourceEditAvailabilityStatus = "unavailable"
)

// AppMetaData defines model for AppMetaData.
type AppMetaData struct {
	// ApplicationTypeId The ID of the application the metadata belongs to
	ApplicationTypeId *string `json:"application_type_id,omitempty"`

	// CreatedAt The timestamp of the creation of the app metadata type
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// Name The name of the step of the metadata
	Name *string `json:"name,omitempty"`

	// Payload The payload of the step
	Payload *map[string]interface{} `json:"payload,omitempty"`

	// UpdatedAt The timestamp of the last time this app metadata type got updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AppMetaDataCollection defines model for AppMetaDataCollection.
type AppMetaDataCollection struct {
	Data  *[]AppMetaData      `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// Application defines model for Application.
type Application struct {
	// ApplicationTypeId ID of the resource
	ApplicationTypeId *ID `json:"application_type_id,omitempty"`

	// AvailabilityStatus The availability status of the application
	AvailabilityStatus *ApplicationAvailabilityStatus `json:"availability_status,omitempty"`

	// AvailabilityStatusError The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// CreatedAt The timestamp of the creation of the application
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Extra Any extra information you want stored for the application, in JSON format
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// LastAvailableAt The timestamp for when the application was last available at.
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// LastCheckedAt Timestamp of the last time the availability was checked for the application
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// PausedAt The timestamp for when the application was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// SourceId ID of the resource
	SourceId *ID `json:"source_id,omitempty"`

	// UpdatedAt The timestamp of the last time this application got updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ApplicationAvailabilityStatus The availability status of the application
type ApplicationAvailabilityStatus string

// ApplicationCreate Expected payload to create an application
type ApplicationCreate struct {
	// ApplicationTypeId ID of the resource. Not "readonly", since it might be used for create/update payloads
	ApplicationTypeId *IDW `json:"application_type_id,omitempty"`

	// Extra Any extra information you want stored for the application, in JSON format
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// SourceId ID of the resource. Not "readonly", since it might be used for create/update payloads
	SourceId *IDW `json:"source_id,omitempty"`
}

// ApplicationType defines model for ApplicationType.
type ApplicationType struct {
	// CreatedAt The timestamp of the creation of the application type
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DependentApplications The dependent applications of this application type
	DependentApplications *map[string]interface{} `json:"dependent_applications,omitempty"`

	// DisplayName The display name for the application type
	DisplayName *string `json:"display_name,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// Name The name for the application type
	Name *string `json:"name,omitempty"`

	// SupportedAuthenticationTypes The supported authentication types the applications of this type support
	SupportedAuthenticationTypes *map[string]interface{} `json:"supported_authentication_types,omitempty"`

	// SupportedSourceTypes The supported source types the applications of this type support
	SupportedSourceTypes *[]string `json:"supported_source_types,omitempty"`

	// UpdatedAt The timestamp of the last time this application type got updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ApplicationTypesCollection defines model for ApplicationTypesCollection.
type ApplicationTypesCollection struct {
	Data  *[]ApplicationType  `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// ApplicationUpdate Expected payload to update an application
type ApplicationUpdate struct {
	// AvailabilityStatus The availability status of the application
	AvailabilityStatus *ApplicationUpdateAvailabilityStatus `json:"availability_status,omitempty"`

	// AvailabilityStatusError The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Extra Any extra information you want stored for the application, in JSON format
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// LastAvailableAt The timestamp for when the application was last available at.
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// LastCheckedAt Timestamp of the last time the availability was checked for the application
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`
}

// ApplicationUpdateAvailabilityStatus The availability status of the application
type ApplicationUpdateAvailabilityStatus string

// ApplicationsCollection defines model for ApplicationsCollection.
type ApplicationsCollection struct {
	Data  *[]Application      `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// AuthenticationRead Authentication object
type AuthenticationRead struct {
	// Authtype The type of the authentication
	Authtype *AuthenticationReadAuthtype `json:"authtype,omitempty"`

	// AvailabilityStatus The availability status of the authentication
	AvailabilityStatus *interface{} `json:"availability_status,omitempty"`

	// AvailabilityStatusError The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Extra Any extra information the authentication may have
	Extra *struct {
		Azure *struct {
			TenantId *string `json:"tenant_id,omitempty"`
		} `json:"azure,omitempty"`

		// Marketplace If the authentication is of the "marketplace-token" type, then this key will contain an unexpired token for the API key that the authentication stores.
		Marketplace *struct {
			// AccessToken The authorization token
			AccessToken *string `json:"access_token,omitempty"`

			// Expiration The Unix timestamp for the expiration of the token
			Expiration *float32 `json:"expiration,omitempty"`
		} `json:"marketplace,omitempty"`
	} `json:"extra,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// Name The authentication's name
	Name *string `json:"name,omitempty"`

	// ResourceId ID of the resource
	ResourceId *ID `json:"resource_id,omitempty"`

	// ResourceType The type of the resource this authentication belongs to
	ResourceType *AuthenticationReadResourceType `json:"resource_type,omitempty"`

	// Username The username for the authentication
	Username *string `json:"username,omitempty"`
}

// AuthenticationReadAuthtype The type of the authentication
type AuthenticationReadAuthtype string

// AuthenticationReadResourceType The type of the resource this authentication belongs to
type AuthenticationReadResourceType string

// AuthenticationsCollection defines model for AuthenticationsCollection.
type AuthenticationsCollection struct {
	Data  *[]AuthenticationRead `json:"data,omitempty"`
	Links *CollectionLinks      `json:"links,omitempty"`
	Meta  *CollectionMetadata   `json:"meta,omitempty"`
}

// BulkCreatePayload defines model for BulkCreatePayload.
type BulkCreatePayload struct {
	// Applications Array of application objects to create. The operation looks up the parent Source by the `source_name` attribute so the `source_name` must match one of the `source` names in the payload. You can specify the application type by using either the `application_type_name` or the `application_type_id`.
	Applications *[]struct {
		// ApplicationTypeId The ID of the application type
		ApplicationTypeId *string `json:"application_type_id,omitempty"`

		// ApplicationTypeName The name of the application type
		ApplicationTypeName *string `json:"application_type_name,omitempty"`

		// Extra Any extra information you would like to store in JSON format
		Extra *map[string]interface{} `json:"extra,omitempty"`

		// SourceId The ID of the soruce this application will be attached to
		SourceId *string `json:"source_id,omitempty"`

		// SourceName The name of the source this application will be attached to
		SourceName string `json:"source_name"`
	} `json:"applications,omitempty"`

	// Authentications Array of authentications to create. `resource_type` tells the action where to look for the parent, must be either application, endpoint or source.
	// If the parent is a source, it looks up by name. If the parent is an endpoint, it looks up via host so the hostname must match. If the parent is an application, it looks up via application type so the value must match the application type which matches.
	Authentications *[]struct {
		// Authtype The type of the authentication. You can find this by listing the source types or the application types
		Authtype *BulkCreatePayloadAuthenticationsAuthtype `json:"authtype,omitempty"`

		// Extra Any extra information you would like to store in JSON format
		Extra *map[string]interface{} `json:"extra,omitempty"`

		// Password The password of the authentication
		Password *string `json:"password,omitempty"`

		// ResourceName The name of the resource this authentication relates to
		ResourceName *string `json:"resource_name,omitempty"`

		// ResourceType The type of the resource this authentication relates to
		ResourceType *BulkCreatePayloadAuthenticationsResourceType `json:"resource_type,omitempty"`

		// Username The username of the authentication
		Username *string `json:"username,omitempty"`
	} `json:"authentications,omitempty"`

	// Endpoints Array of endpoint objects to create. The operation looks up the parent source by the `source_name` attribute so the `source_name` must match one of the `source`'s names in the payload.
	Endpoints *[]struct {
		// CertificateAuthority Optional X.509 Certificate Authority.
		CertificateAuthority *string `json:"certificate_authority,omitempty"`

		// Host URI host component of the endpoint.
		Host *string `json:"host,omitempty"`

		// Path URI path component of the endpoint.
		Path *string `json:"path,omitempty"`

		// Port URI port component of the endpoint.
		Port *int `json:"port,omitempty"`

		// Scheme URI scheme component of the endpoint.
		Scheme *string `json:"scheme,omitempty"`

		// SourceName The name of the source this endpoint will be attached to
		SourceName string `json:"source_name"`

		// VerifySsl Should the SSL certificate be verified?
		VerifySsl *bool `json:"verify_ssl,omitempty"`
	} `json:"endpoints,omitempty"`

	// Sources Array of source objects to create
	Sources *[]struct {
		// AppCreationWorkflow The way the source is going to be created: manually, or using superkey?
		AppCreationWorkflow *BulkCreatePayloadSourcesAppCreationWorkflow `json:"app_creation_workflow,omitempty"`

		// Name The name of the source
		Name string `json:"name"`

		// SourceRef The external referece or ID for the source
		SourceRef *string `json:"source_ref,omitempty"`

		// SourceTypeName The type of the source that will be created
		SourceTypeName BulkCreatePayloadSourcesSourceTypeName `json:"source_type_name"`
	} `json:"sources,omitempty"`
}

// BulkCreatePayloadAuthenticationsAuthtype The type of the authentication. You can find this by listing the source types or the application types
type BulkCreatePayloadAuthenticationsAuthtype string

// BulkCreatePayloadAuthenticationsResourceType The type of the resource this authentication relates to
type BulkCreatePayloadAuthenticationsResourceType string

// BulkCreatePayloadSourcesAppCreationWorkflow The way the source is going to be created: manually, or using superkey?
type BulkCreatePayloadSourcesAppCreationWorkflow string

// BulkCreatePayloadSourcesSourceTypeName The type of the source that will be created
type BulkCreatePayloadSourcesSourceTypeName string

// CollectionLinks defines model for CollectionLinks.
type CollectionLinks struct {
	// First The link to the first object of the list
	First *string `json:"first,omitempty"`

	// Last The link to the last object of the list
	Last *string `json:"last,omitempty"`

	// Next The link to the next page of objects
	Next *string `json:"next,omitempty"`

	// Prev The link to the previous page of objects
	Prev *string `json:"prev,omitempty"`
}

// CollectionMetadata defines model for CollectionMetadata.
type CollectionMetadata struct {
	// Count The total amount of objects in the database
	Count *int `json:"count,omitempty"`

	// Limit The limit of objects that was applied to the object list
	Limit *int `json:"limit,omitempty"`

	// Offset The offset that was applied to the list
	Offset *int `json:"offset,omitempty"`
}

// Endpoint Representation of an endpoint object
type Endpoint struct {
	// AvailabilityStatus The availability status of the endpoint.
	AvailabilityStatus *EndpointAvailabilityStatus `json:"availability_status,omitempty"`

	// AvailabilityStatusError The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// CertificateAuthority Optional X.509 Certificate Authority
	CertificateAuthority *string `json:"certificate_authority,omitempty"`

	// CreatedAt The timestamp for when the endpoint was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Default Mark endpoint as the default endpoint? Each source can only have one default endpoint. It gets set to true by default if the given source has no endpoints.
	Default *bool `json:"default,omitempty"`

	// Host URI host component of the endpoint.
	Host *string `json:"host,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// LastAvailableAt Timestamp of the last time the connection was available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// LastCheckedAt Timestamp of the last time the availability was checked for the connection
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// Path URI path component of the endpoint.
	Path *string `json:"path,omitempty"`

	// PausedAt The timestamp for when the endpoint was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// Port URI port component of the endpoint.
	Port *int `json:"port,omitempty"`

	// ReceptorNode Identifier of a receptor node.
	ReceptorNode *string `json:"receptor_node,omitempty"`

	// Role The role of the endpoint. It must be unique among the source's endpoints.
	Role *string `json:"role,omitempty"`

	// Scheme The scheme of the protocol.
	Scheme *string `json:"scheme,omitempty"`

	// SourceId ID of the resource
	SourceId *ID `json:"source_id,omitempty"`

	// UpdatedAt The timestamp for when the source was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// VerifySsl Should the SSL certificate be verified?
	VerifySsl *bool `json:"verify_ssl,omitempty"`
}

// EndpointAvailabilityStatus The availability status of the endpoint.
type EndpointAvailabilityStatus string

// EndpointRead Endpoint object
type EndpointRead struct {
	// AvailabilityStatus The availability status of the endpoint.
	AvailabilityStatus *EndpointReadAvailabilityStatus `json:"availability_status,omitempty"`

	// AvailabilityStatusError The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// CertificateAuthority Optional X.509 Certificate Authority
	CertificateAuthority *string `json:"certificate_authority,omitempty"`

	// CreatedAt The timestamp for when the endpoint was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Default Mark endpoint as the default endpoint? Each source can only have one default endpoint. It gets set to true by default if the given source has no endpoints.
	Default *bool `json:"default,omitempty"`

	// Host URI host component of the endpoint.
	Host *string `json:"host,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// LastAvailableAt Timestamp of the last time the connection was available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// LastCheckedAt Timestamp of the last time the availability was checked for the connection
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// Path URI path component of the endpoint.
	Path *string `json:"path,omitempty"`

	// PausedAt The timestamp for when the endpoint was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// Port URI port component of the endpoint.
	Port *int `json:"port,omitempty"`

	// ReceptorNode Identifier of a receptor node.
	ReceptorNode *string `json:"receptor_node,omitempty"`

	// Role The role of the endpoint. It must be unique among the source's endpoints.
	Role *string `json:"role,omitempty"`

	// Scheme The scheme of the protocol.
	Scheme *string `json:"scheme,omitempty"`

	// SourceId ID of the resource
	SourceId *ID `json:"source_id,omitempty"`

	// UpdatedAt The timestamp for when the source was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// VerifySsl Should the SSL certificate be verified?
	VerifySsl *bool `json:"verify_ssl,omitempty"`
}

// EndpointReadAvailabilityStatus The availability status of the endpoint.
type EndpointReadAvailabilityStatus string

// EndpointsCollection defines model for EndpointsCollection.
type EndpointsCollection struct {
	Data  *[]EndpointRead     `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// ErrorBadRequest Error structure for the "Bad Request" responses
type ErrorBadRequest struct {
	Errors *[]struct {
		// Detail Detail of the error
		Detail *string `json:"detail,omitempty"`

		// Status Status of the response
		Status *string `json:"status,omitempty"`
	} `json:"errors,omitempty"`
}

// ErrorNotFound Error structure for the "Not Found" responses
type ErrorNotFound struct {
	Errors *[]struct {
		// Detail Detail of the error
		Detail *string `json:"detail,omitempty"`

		// Status Status of the response
		Status *string `json:"status,omitempty"`
	} `json:"errors,omitempty"`
}

// IDW ID of the resource. Not "readonly", since it might be used for create/update payloads
type IDW = string

// RhcConnectionCollection Collection of Red Hat Connector Connections along with the metadata
type RhcConnectionCollection struct {
	Data  *[]RhcConnectionRead `json:"data,omitempty"`
	Links *CollectionLinks     `json:"links,omitempty"`
	Meta  *CollectionMetadata  `json:"meta,omitempty"`
}

// RhcConnectionRead defines model for RhcConnectionRead.
type RhcConnectionRead struct {
	// AvailabilityStatus The availability status of the connection
	AvailabilityStatus *RhcConnectionReadAvailabilityStatus `json:"availability_status,omitempty"`

	// AvailabilityStatusError The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Extra Extra data in JSON format
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// LastAvailableAt Timestamp of the last time the connection was available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// LastCheckedAt Timestamp of the last time the availability was checked for the connection
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// RhcId The UUID of the connection
	RhcId *string `json:"rhc_id,omitempty"`

	// SourceIds The connection's related sources
	SourceIds *[]ID `json:"source_ids,omitempty"`
}

// RhcConnectionReadAvailabilityStatus The availability status of the connection
type RhcConnectionReadAvailabilityStatus string

// Source defines model for Source.
type Source struct {
	AppCreationWorkflow *SourceAppCreationWorkflow `json:"app_creation_workflow,omitempty"`

	// AvailabilityStatus The availability status of the source
	AvailabilityStatus *SourceAvailabilityStatus `json:"availability_status,omitempty"`

	// CreatedAt The timestamp for when the source was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id ID of the resource
	Id *ID `json:"id,omitempty"`

	// Imported Was the source imported?
	Imported *string `json:"imported,omitempty"`

	// LastAvailableAt The timestamp for when the source was last available at.
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// LastCheckedAt The timestamp for when the source was last checked at for the availability status.
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// Name The name of the source
	Name *string `json:"name,omitempty"`

	// PausedAt The timestamp for when the source was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// SourceRef The external referece or ID for the source
	SourceRef *string `json:"source_ref,omitempty"`

	// SourceTypeId ID of the resource
	SourceTypeId *ID `json:"source_type_id,omitempty"`

	// Uid Unique ID of the inventory source installation
	Uid *string `json:"uid,omitempty"`

	// UpdatedAt The timestamp for when the source was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version The version of the source
	Version *string `json:"version,omitempty"`
}

// SourceAppCreationWorkflow defines model for Source.AppCreationWorkflow.
type SourceAppCreationWorkflow string

// SourceAvailabilityStatus The availability status of the source
type SourceAvailabilityStatus string

// SourceCreate The payload that the back end accepts when creating a source
type SourceCreate struct {
	// AppCreationWorkflow The way the source is going to be created: manually, or using superkey?
	AppCreationWorkflow *SourceCreateAppCreationWorkflow `json:"app_creation_workflow,omitempty"`

	// AvailabilityStatus The availability status of the source
	AvailabilityStatus *SourceCreateAvailabilityStatus `json:"availability_status,omitempty"`

	// Imported Was the source imported?
	Imported *string `json:"imported,omitempty"`

	// Name The name of the source
	Name *string `json:"name,omitempty"`

	// SourceRef The external referece or ID for the source
	SourceRef *string `json:"source_ref,omitempty"`

	// SourceTypeId The ID of the source type
	SourceTypeId *string `json:"source_type_id,omitempty"`

	// Uid Unique ID of the inventory source installation
	Uid *string `json:"uid,omitempty"`

	// Version The version of the source
	Version *string `json:"version,omitempty"`
}

// SourceCreateAppCreationWorkflow The way the source is going to be created: manually, or using superkey?
type SourceCreateAppCreationWorkflow string

// SourceCreateAvailabilityStatus The availability status of the source
type SourceCreateAvailabilityStatus string

// SourceEdit The payload that the back end accepts when editing a source
type SourceEdit struct {
	// AvailabilityStatus The availability status of the source
	AvailabilityStatus *SourceEditAvailabilityStatus `json:"availability_status,omitempty"`

	// Imported Was the source imported?
	Imported *string `json:"imported,omitempty"`

	// LastAvailableAt The timestamp of the last time the source was seen as available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// LastCheckedAt The timestamp of the last time the source was checked for the availability status
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// Name The name of the source
	Name *string `json:"name,omitempty"`

	// SourceRef The external referece or ID for the source
	SourceRef *string `json:"source_ref,omitempty"`

	// Version The version of the source
	Version *string `json:"version,omitempty"`
}

// SourceEditAvailabilityStatus The availability status of the source
type SourceEditAvailabilityStatus string

// SourcesCollection An array containing source objects
type SourcesCollection struct {
	Data  *[]Source           `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// ID defines model for ID.
type ID = string

// QueryFilter defines model for QueryFilter.
type QueryFilter = string

// QueryLimit defines model for QueryLimit.
type QueryLimit = int

// QueryOffset defines model for QueryOffset.
type QueryOffset = int

// QuerySortBy defines model for QuerySortBy.
type QuerySortBy = string

// BadRequest Error structure for the "Bad Request" responses
type BadRequest = ErrorBadRequest

// NotFound Error structure for the "Not Found" responses
type NotFound = ErrorNotFound

// ListApplicationTypesParams defines parameters for ListApplicationTypes.
type ListApplicationTypesParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListApplicationTypeAppMetaDataParams defines parameters for ListApplicationTypeAppMetaData.
type ListApplicationTypeAppMetaDataParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListApplicationTypeSourcesParams defines parameters for ListApplicationTypeSources.
type ListApplicationTypeSourcesParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListApplicationsParams defines parameters for ListApplications.
type ListApplicationsParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListApplicationAuthenticationsParams defines parameters for ListApplicationAuthentications.
type ListApplicationAuthenticationsParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourcesParams defines parameters for ListSources.
type ListSourcesParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourceApplicationTypesParams defines parameters for ListSourceApplicationTypes.
type ListSourceApplicationTypesParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourceApplicationsParams defines parameters for ListSourceApplications.
type ListSourceApplicationsParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourceAuthenticationsParams defines parameters for ListSourceAuthentications.
type ListSourceAuthenticationsParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourceEndpointsParams defines parameters for ListSourceEndpoints.
type ListSourceEndpointsParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// GetSourcesRhcConnectionParams defines parameters for GetSourcesRhcConnection.
type GetSourcesRhcConnectionParams struct {
	// Limit The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// SortBy The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// CreateApplicationJSONRequestBody defines body for CreateApplication for application/json ContentType.
type CreateApplicationJSONRequestBody = ApplicationCreate

// UpdateApplicationJSONRequestBody defines body for UpdateApplication for application/json ContentType.
type UpdateApplicationJSONRequestBody = ApplicationUpdate

// BulkCreateJSONRequestBody defines body for BulkCreate for application/json ContentType.
type BulkCreateJSONRequestBody = BulkCreatePayload

// CreateSourceJSONRequestBody defines body for CreateSource for application/json ContentType.
type CreateSourceJSONRequestBody = SourceCreate

// UpdateSourceJSONRequestBody defines body for UpdateSource for application/json ContentType.
type UpdateSourceJSONRequestBody = SourceEdit

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApplicationTypes request
	ListApplicationTypes(ctx context.Context, params *ListApplicationTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowApplicationType request
	ShowApplicationType(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApplicationTypeAppMetaData request
	ListApplicationTypeAppMetaData(ctx context.Context, id ID, params *ListApplicationTypeAppMetaDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApplicationTypeSources request
	ListApplicationTypeSources(ctx context.Context, id ID, params *ListApplicationTypeSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApplications request
	ListApplications(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApplication request with any body
	CreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApplication(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApplication request
	DeleteApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowApplication request
	ShowApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApplication request with any body
	UpdateApplicationWithBody(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApplication(ctx context.Context, id ID, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApplicationAuthentications request
	ListApplicationAuthentications(ctx context.Context, id ID, params *ListApplicationAuthenticationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseApplication request
	PauseApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnpauseApplication request
	UnpauseApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreate request with any body
	BulkCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreate(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSources request
	ListSources(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSource request with any body
	CreateSourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSource(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSource request
	DeleteSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowSource request
	ShowSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSource request with any body
	UpdateSourceWithBody(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSource(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceApplicationTypes request
	ListSourceApplicationTypes(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceApplications request
	ListSourceApplications(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceAuthentications request
	ListSourceAuthentications(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckAvailabilitySource request
	CheckAvailabilitySource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceEndpoints request
	ListSourceEndpoints(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseSource request
	PauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSourcesRhcConnection request
	GetSourcesRhcConnection(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnpauseSource request
	UnpauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApplicationTypes(ctx context.Context, params *ListApplicationTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowApplicationType(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowApplicationTypeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApplicationTypeAppMetaData(ctx context.Context, id ID, params *ListApplicationTypeAppMetaDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationTypeAppMetaDataRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApplicationTypeSources(ctx context.Context, id ID, params *ListApplicationTypeSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationTypeSourcesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApplications(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplication(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApplicationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowApplicationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplicationWithBody(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplication(ctx context.Context, id ID, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApplicationAuthentications(ctx context.Context, id ID, params *ListApplicationAuthenticationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationAuthenticationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseApplicationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpauseApplication(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpauseApplicationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreate(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSources(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSource(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceWithBody(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSource(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceApplicationTypes(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceApplicationTypesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceApplications(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceApplicationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceAuthentications(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceAuthenticationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAvailabilitySource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAvailabilitySourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceEndpoints(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceEndpointsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSourcesRhcConnection(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourcesRhcConnectionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpauseSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListApplicationTypesRequest generates requests for ListApplicationTypes
func NewListApplicationTypesRequest(server string, params *ListApplicationTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/application_types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowApplicationTypeRequest generates requests for ShowApplicationType
func NewShowApplicationTypeRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/application_types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApplicationTypeAppMetaDataRequest generates requests for ListApplicationTypeAppMetaData
func NewListApplicationTypeAppMetaDataRequest(server string, id ID, params *ListApplicationTypeAppMetaDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/application_types/%s/app_meta_data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApplicationTypeSourcesRequest generates requests for ListApplicationTypeSources
func NewListApplicationTypeSourcesRequest(server string, id ID, params *ListApplicationTypeSourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/application_types/%s/sources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApplicationsRequest generates requests for ListApplications
func NewListApplicationsRequest(server string, params *ListApplicationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApplicationRequest calls the generic CreateApplication builder with application/json body
func NewCreateApplicationRequest(server string, body CreateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateApplicationRequestWithBody generates requests for CreateApplication with any type of body
func NewCreateApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApplicationRequest generates requests for DeleteApplication
func NewDeleteApplicationRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowApplicationRequest generates requests for ShowApplication
func NewShowApplicationRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateApplicationRequest calls the generic UpdateApplication builder with application/json body
func NewUpdateApplicationRequest(server string, id ID, body UpdateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateApplicationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateApplicationRequestWithBody generates requests for UpdateApplication with any type of body
func NewUpdateApplicationRequestWithBody(server string, id ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListApplicationAuthenticationsRequest generates requests for ListApplicationAuthentications
func NewListApplicationAuthenticationsRequest(server string, id ID, params *ListApplicationAuthenticationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/authentications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPauseApplicationRequest generates requests for PauseApplication
func NewPauseApplicationRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnpauseApplicationRequest generates requests for UnpauseApplication
func NewUnpauseApplicationRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/unpause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkCreateRequest calls the generic BulkCreate builder with application/json body
func NewBulkCreateRequest(server string, body BulkCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateRequestWithBody generates requests for BulkCreate with any type of body
func NewBulkCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bulk_create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSourcesRequest generates requests for ListSources
func NewListSourcesRequest(server string, params *ListSourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSourceRequest calls the generic CreateSource builder with application/json body
func NewCreateSourceRequest(server string, body CreateSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSourceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSourceRequestWithBody generates requests for CreateSource with any type of body
func NewCreateSourceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSourceRequest generates requests for DeleteSource
func NewDeleteSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowSourceRequest generates requests for ShowSource
func NewShowSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSourceRequest calls the generic UpdateSource builder with application/json body
func NewUpdateSourceRequest(server string, id ID, body UpdateSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSourceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSourceRequestWithBody generates requests for UpdateSource with any type of body
func NewUpdateSourceRequestWithBody(server string, id ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSourceApplicationTypesRequest generates requests for ListSourceApplicationTypes
func NewListSourceApplicationTypesRequest(server string, id ID, params *ListSourceApplicationTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/application_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourceApplicationsRequest generates requests for ListSourceApplications
func NewListSourceApplicationsRequest(server string, id ID, params *ListSourceApplicationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/applications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourceAuthenticationsRequest generates requests for ListSourceAuthentications
func NewListSourceAuthenticationsRequest(server string, id ID, params *ListSourceAuthenticationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/authentications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckAvailabilitySourceRequest generates requests for CheckAvailabilitySource
func NewCheckAvailabilitySourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/check_availability", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourceEndpointsRequest generates requests for ListSourceEndpoints
func NewListSourceEndpointsRequest(server string, id ID, params *ListSourceEndpointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPauseSourceRequest generates requests for PauseSource
func NewPauseSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourcesRhcConnectionRequest generates requests for GetSourcesRhcConnection
func NewGetSourcesRhcConnectionRequest(server string, id ID, params *GetSourcesRhcConnectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/rhc_connections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnpauseSourceRequest generates requests for UnpauseSource
func NewUnpauseSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/unpause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListApplicationTypes request
	ListApplicationTypesWithResponse(ctx context.Context, params *ListApplicationTypesParams, reqEditors ...RequestEditorFn) (*ListApplicationTypesResponse, error)

	// ShowApplicationType request
	ShowApplicationTypeWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowApplicationTypeResponse, error)

	// ListApplicationTypeAppMetaData request
	ListApplicationTypeAppMetaDataWithResponse(ctx context.Context, id ID, params *ListApplicationTypeAppMetaDataParams, reqEditors ...RequestEditorFn) (*ListApplicationTypeAppMetaDataResponse, error)

	// ListApplicationTypeSources request
	ListApplicationTypeSourcesWithResponse(ctx context.Context, id ID, params *ListApplicationTypeSourcesParams, reqEditors ...RequestEditorFn) (*ListApplicationTypeSourcesResponse, error)

	// ListApplications request
	ListApplicationsWithResponse(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*ListApplicationsResponse, error)

	// CreateApplication request with any body
	CreateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error)

	CreateApplicationWithResponse(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error)

	// DeleteApplication request
	DeleteApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*DeleteApplicationResponse, error)

	// ShowApplication request
	ShowApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowApplicationResponse, error)

	// UpdateApplication request with any body
	UpdateApplicationWithBodyWithResponse(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error)

	UpdateApplicationWithResponse(ctx context.Context, id ID, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error)

	// ListApplicationAuthentications request
	ListApplicationAuthenticationsWithResponse(ctx context.Context, id ID, params *ListApplicationAuthenticationsParams, reqEditors ...RequestEditorFn) (*ListApplicationAuthenticationsResponse, error)

	// PauseApplication request
	PauseApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*PauseApplicationResponse, error)

	// UnpauseApplication request
	UnpauseApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*UnpauseApplicationResponse, error)

	// BulkCreate request with any body
	BulkCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error)

	BulkCreateWithResponse(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error)

	// ListSources request
	ListSourcesWithResponse(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*ListSourcesResponse, error)

	// CreateSource request with any body
	CreateSourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error)

	CreateSourceWithResponse(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error)

	// DeleteSource request
	DeleteSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error)

	// ShowSource request
	ShowSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowSourceResponse, error)

	// UpdateSource request with any body
	UpdateSourceWithBodyWithResponse(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	UpdateSourceWithResponse(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	// ListSourceApplicationTypes request
	ListSourceApplicationTypesWithResponse(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationTypesResponse, error)

	// ListSourceApplications request
	ListSourceApplicationsWithResponse(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationsResponse, error)

	// ListSourceAuthentications request
	ListSourceAuthenticationsWithResponse(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*ListSourceAuthenticationsResponse, error)

	// CheckAvailabilitySource request
	CheckAvailabilitySourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*CheckAvailabilitySourceResponse, error)

	// ListSourceEndpoints request
	ListSourceEndpointsWithResponse(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*ListSourceEndpointsResponse, error)

	// PauseSource request
	PauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*PauseSourceResponse, error)

	// GetSourcesRhcConnection request
	GetSourcesRhcConnectionWithResponse(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*GetSourcesRhcConnectionResponse, error)

	// UnpauseSource request
	UnpauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*UnpauseSourceResponse, error)
}

type ListApplicationTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationTypesCollection
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r ListApplicationTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowApplicationTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationType
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ShowApplicationTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowApplicationTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApplicationTypeAppMetaDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppMetaDataCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListApplicationTypeAppMetaDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationTypeAppMetaDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApplicationTypeSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SourcesCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListApplicationTypeSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationTypeSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApplicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationsCollection
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r ListApplicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Application
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r CreateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r DeleteApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ShowApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r UpdateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApplicationAuthenticationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationsCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListApplicationAuthenticationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationAuthenticationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r PauseApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpauseApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r UnpauseApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpauseApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BulkCreateResponse
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r BulkCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SourcesCollection
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r ListSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Source
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r CreateSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r DeleteSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ShowSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r UpdateSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceApplicationTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationTypesCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceApplicationTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceApplicationTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceApplicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationsCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceApplicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceApplicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceAuthenticationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationsCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceAuthenticationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceAuthenticationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckAvailabilitySourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r CheckAvailabilitySourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAvailabilitySourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointsCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r PauseSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourcesRhcConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RhcConnectionCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r GetSourcesRhcConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourcesRhcConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpauseSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r UnpauseSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpauseSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListApplicationTypesWithResponse request returning *ListApplicationTypesResponse
func (c *ClientWithResponses) ListApplicationTypesWithResponse(ctx context.Context, params *ListApplicationTypesParams, reqEditors ...RequestEditorFn) (*ListApplicationTypesResponse, error) {
	rsp, err := c.ListApplicationTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationTypesResponse(rsp)
}

// ShowApplicationTypeWithResponse request returning *ShowApplicationTypeResponse
func (c *ClientWithResponses) ShowApplicationTypeWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowApplicationTypeResponse, error) {
	rsp, err := c.ShowApplicationType(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowApplicationTypeResponse(rsp)
}

// ListApplicationTypeAppMetaDataWithResponse request returning *ListApplicationTypeAppMetaDataResponse
func (c *ClientWithResponses) ListApplicationTypeAppMetaDataWithResponse(ctx context.Context, id ID, params *ListApplicationTypeAppMetaDataParams, reqEditors ...RequestEditorFn) (*ListApplicationTypeAppMetaDataResponse, error) {
	rsp, err := c.ListApplicationTypeAppMetaData(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationTypeAppMetaDataResponse(rsp)
}

// ListApplicationTypeSourcesWithResponse request returning *ListApplicationTypeSourcesResponse
func (c *ClientWithResponses) ListApplicationTypeSourcesWithResponse(ctx context.Context, id ID, params *ListApplicationTypeSourcesParams, reqEditors ...RequestEditorFn) (*ListApplicationTypeSourcesResponse, error) {
	rsp, err := c.ListApplicationTypeSources(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationTypeSourcesResponse(rsp)
}

// ListApplicationsWithResponse request returning *ListApplicationsResponse
func (c *ClientWithResponses) ListApplicationsWithResponse(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*ListApplicationsResponse, error) {
	rsp, err := c.ListApplications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationsResponse(rsp)
}

// CreateApplicationWithBodyWithResponse request with arbitrary body returning *CreateApplicationResponse
func (c *ClientWithResponses) CreateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error) {
	rsp, err := c.CreateApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreateApplicationWithResponse(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error) {
	rsp, err := c.CreateApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationResponse(rsp)
}

// DeleteApplicationWithResponse request returning *DeleteApplicationResponse
func (c *ClientWithResponses) DeleteApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*DeleteApplicationResponse, error) {
	rsp, err := c.DeleteApplication(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApplicationResponse(rsp)
}

// ShowApplicationWithResponse request returning *ShowApplicationResponse
func (c *ClientWithResponses) ShowApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowApplicationResponse, error) {
	rsp, err := c.ShowApplication(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowApplicationResponse(rsp)
}

// UpdateApplicationWithBodyWithResponse request with arbitrary body returning *UpdateApplicationResponse
func (c *ClientWithResponses) UpdateApplicationWithBodyWithResponse(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error) {
	rsp, err := c.UpdateApplicationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationResponse(rsp)
}

func (c *ClientWithResponses) UpdateApplicationWithResponse(ctx context.Context, id ID, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error) {
	rsp, err := c.UpdateApplication(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationResponse(rsp)
}

// ListApplicationAuthenticationsWithResponse request returning *ListApplicationAuthenticationsResponse
func (c *ClientWithResponses) ListApplicationAuthenticationsWithResponse(ctx context.Context, id ID, params *ListApplicationAuthenticationsParams, reqEditors ...RequestEditorFn) (*ListApplicationAuthenticationsResponse, error) {
	rsp, err := c.ListApplicationAuthentications(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationAuthenticationsResponse(rsp)
}

// PauseApplicationWithResponse request returning *PauseApplicationResponse
func (c *ClientWithResponses) PauseApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*PauseApplicationResponse, error) {
	rsp, err := c.PauseApplication(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseApplicationResponse(rsp)
}

// UnpauseApplicationWithResponse request returning *UnpauseApplicationResponse
func (c *ClientWithResponses) UnpauseApplicationWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*UnpauseApplicationResponse, error) {
	rsp, err := c.UnpauseApplication(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpauseApplicationResponse(rsp)
}

// BulkCreateWithBodyWithResponse request with arbitrary body returning *BulkCreateResponse
func (c *ClientWithResponses) BulkCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error) {
	rsp, err := c.BulkCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateWithResponse(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error) {
	rsp, err := c.BulkCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateResponse(rsp)
}

// ListSourcesWithResponse request returning *ListSourcesResponse
func (c *ClientWithResponses) ListSourcesWithResponse(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*ListSourcesResponse, error) {
	rsp, err := c.ListSources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourcesResponse(rsp)
}

// CreateSourceWithBodyWithResponse request with arbitrary body returning *CreateSourceResponse
func (c *ClientWithResponses) CreateSourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error) {
	rsp, err := c.CreateSourceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceResponse(rsp)
}

func (c *ClientWithResponses) CreateSourceWithResponse(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error) {
	rsp, err := c.CreateSource(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceResponse(rsp)
}

// DeleteSourceWithResponse request returning *DeleteSourceResponse
func (c *ClientWithResponses) DeleteSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error) {
	rsp, err := c.DeleteSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSourceResponse(rsp)
}

// ShowSourceWithResponse request returning *ShowSourceResponse
func (c *ClientWithResponses) ShowSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowSourceResponse, error) {
	rsp, err := c.ShowSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowSourceResponse(rsp)
}

// UpdateSourceWithBodyWithResponse request with arbitrary body returning *UpdateSourceResponse
func (c *ClientWithResponses) UpdateSourceWithBodyWithResponse(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSourceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSourceWithResponse(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSource(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

// ListSourceApplicationTypesWithResponse request returning *ListSourceApplicationTypesResponse
func (c *ClientWithResponses) ListSourceApplicationTypesWithResponse(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationTypesResponse, error) {
	rsp, err := c.ListSourceApplicationTypes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceApplicationTypesResponse(rsp)
}

// ListSourceApplicationsWithResponse request returning *ListSourceApplicationsResponse
func (c *ClientWithResponses) ListSourceApplicationsWithResponse(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationsResponse, error) {
	rsp, err := c.ListSourceApplications(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceApplicationsResponse(rsp)
}

// ListSourceAuthenticationsWithResponse request returning *ListSourceAuthenticationsResponse
func (c *ClientWithResponses) ListSourceAuthenticationsWithResponse(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*ListSourceAuthenticationsResponse, error) {
	rsp, err := c.ListSourceAuthentications(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceAuthenticationsResponse(rsp)
}

// CheckAvailabilitySourceWithResponse request returning *CheckAvailabilitySourceResponse
func (c *ClientWithResponses) CheckAvailabilitySourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*CheckAvailabilitySourceResponse, error) {
	rsp, err := c.CheckAvailabilitySource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAvailabilitySourceResponse(rsp)
}

// ListSourceEndpointsWithResponse request returning *ListSourceEndpointsResponse
func (c *ClientWithResponses) ListSourceEndpointsWithResponse(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*ListSourceEndpointsResponse, error) {
	rsp, err := c.ListSourceEndpoints(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceEndpointsResponse(rsp)
}

// PauseSourceWithResponse request returning *PauseSourceResponse
func (c *ClientWithResponses) PauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*PauseSourceResponse, error) {
	rsp, err := c.PauseSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseSourceResponse(rsp)
}

// GetSourcesRhcConnectionWithResponse request returning *GetSourcesRhcConnectionResponse
func (c *ClientWithResponses) GetSourcesRhcConnectionWithResponse(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*GetSourcesRhcConnectionResponse, error) {
	rsp, err := c.GetSourcesRhcConnection(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourcesRhcConnectionResponse(rsp)
}

// UnpauseSourceWithResponse request returning *UnpauseSourceResponse
func (c *ClientWithResponses) UnpauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*UnpauseSourceResponse, error) {
	rsp, err := c.UnpauseSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpauseSourceResponse(rsp)
}

// ParseListApplicationTypesResponse parses an HTTP response from a ListApplicationTypesWithResponse call
func ParseListApplicationTypesResponse(rsp *http.Response) (*ListApplicationTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationTypesCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseShowApplicationTypeResponse parses an HTTP response from a ShowApplicationTypeWithResponse call
func ParseShowApplicationTypeResponse(rsp *http.Response) (*ShowApplicationTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowApplicationTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListApplicationTypeAppMetaDataResponse parses an HTTP response from a ListApplicationTypeAppMetaDataWithResponse call
func ParseListApplicationTypeAppMetaDataResponse(rsp *http.Response) (*ListApplicationTypeAppMetaDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationTypeAppMetaDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppMetaDataCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListApplicationTypeSourcesResponse parses an HTTP response from a ListApplicationTypeSourcesWithResponse call
func ParseListApplicationTypeSourcesResponse(rsp *http.Response) (*ListApplicationTypeSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationTypeSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SourcesCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListApplicationsResponse parses an HTTP response from a ListApplicationsWithResponse call
func ParseListApplicationsResponse(rsp *http.Response) (*ListApplicationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateApplicationResponse parses an HTTP response from a CreateApplicationWithResponse call
func ParseCreateApplicationResponse(rsp *http.Response) (*CreateApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteApplicationResponse parses an HTTP response from a DeleteApplicationWithResponse call
func ParseDeleteApplicationResponse(rsp *http.Response) (*DeleteApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseShowApplicationResponse parses an HTTP response from a ShowApplicationWithResponse call
func ParseShowApplicationResponse(rsp *http.Response) (*ShowApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateApplicationResponse parses an HTTP response from a UpdateApplicationWithResponse call
func ParseUpdateApplicationResponse(rsp *http.Response) (*UpdateApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListApplicationAuthenticationsResponse parses an HTTP response from a ListApplicationAuthenticationsWithResponse call
func ParseListApplicationAuthenticationsResponse(rsp *http.Response) (*ListApplicationAuthenticationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationAuthenticationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePauseApplicationResponse parses an HTTP response from a PauseApplicationWithResponse call
func ParsePauseApplicationResponse(rsp *http.Response) (*PauseApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnpauseApplicationResponse parses an HTTP response from a UnpauseApplicationWithResponse call
func ParseUnpauseApplicationResponse(rsp *http.Response) (*UnpauseApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpauseApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBulkCreateResponse parses an HTTP response from a BulkCreateWithResponse call
func ParseBulkCreateResponse(rsp *http.Response) (*BulkCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BulkCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListSourcesResponse parses an HTTP response from a ListSourcesWithResponse call
func ParseListSourcesResponse(rsp *http.Response) (*ListSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SourcesCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateSourceResponse parses an HTTP response from a CreateSourceWithResponse call
func ParseCreateSourceResponse(rsp *http.Response) (*CreateSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteSourceResponse parses an HTTP response from a DeleteSourceWithResponse call
func ParseDeleteSourceResponse(rsp *http.Response) (*DeleteSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseShowSourceResponse parses an HTTP response from a ShowSourceWithResponse call
func ParseShowSourceResponse(rsp *http.Response) (*ShowSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSourceResponse parses an HTTP response from a UpdateSourceWithResponse call
func ParseUpdateSourceResponse(rsp *http.Response) (*UpdateSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceApplicationTypesResponse parses an HTTP response from a ListSourceApplicationTypesWithResponse call
func ParseListSourceApplicationTypesResponse(rsp *http.Response) (*ListSourceApplicationTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceApplicationTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationTypesCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceApplicationsResponse parses an HTTP response from a ListSourceApplicationsWithResponse call
func ParseListSourceApplicationsResponse(rsp *http.Response) (*ListSourceApplicationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceApplicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceAuthenticationsResponse parses an HTTP response from a ListSourceAuthenticationsWithResponse call
func ParseListSourceAuthenticationsResponse(rsp *http.Response) (*ListSourceAuthenticationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceAuthenticationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCheckAvailabilitySourceResponse parses an HTTP response from a CheckAvailabilitySourceWithResponse call
func ParseCheckAvailabilitySourceResponse(rsp *http.Response) (*CheckAvailabilitySourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckAvailabilitySourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceEndpointsResponse parses an HTTP response from a ListSourceEndpointsWithResponse call
func ParseListSourceEndpointsResponse(rsp *http.Response) (*ListSourceEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePauseSourceResponse parses an HTTP response from a PauseSourceWithResponse call
func ParsePauseSourceResponse(rsp *http.Response) (*PauseSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSourcesRhcConnectionResponse parses an HTTP response from a GetSourcesRhcConnectionWithResponse call
func ParseGetSourcesRhcConnectionResponse(rsp *http.Response) (*GetSourcesRhcConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourcesRhcConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RhcConnectionCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnpauseSourceResponse parses an HTTP response from a UnpauseSourceWithResponse call
func ParseUnpauseSourceResponse(rsp *http.Response) (*UnpauseSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpauseSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
