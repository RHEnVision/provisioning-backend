// Package sources provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package sources

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	Basic_authScopes                  = "basic_auth.Scopes"
	X_rh_identityScopes               = "x_rh_identity.Scopes"
	X_rh_sources_account_numberScopes = "x_rh_sources_account_number.Scopes"
	X_rh_sources_org_idScopes         = "x_rh_sources_org_id.Scopes"
)

// Defines values for ApplicationAvailabilityStatus.
const (
	ApplicationAvailabilityStatusAvailable          ApplicationAvailabilityStatus = "available"
	ApplicationAvailabilityStatusInProgress         ApplicationAvailabilityStatus = "in_progress"
	ApplicationAvailabilityStatusPartiallyAvailable ApplicationAvailabilityStatus = "partially_available"
	ApplicationAvailabilityStatusUnavailable        ApplicationAvailabilityStatus = "unavailable"
)

// Defines values for AuthenticationCreateResourceType.
const (
	AuthenticationCreateResourceTypeApplication    AuthenticationCreateResourceType = "Application"
	AuthenticationCreateResourceTypeAuthentication AuthenticationCreateResourceType = "Authentication"
	AuthenticationCreateResourceTypeEndpoint       AuthenticationCreateResourceType = "Endpoint"
	AuthenticationCreateResourceTypeSource         AuthenticationCreateResourceType = "Source"
)

// Defines values for AuthenticationReadResourceType.
const (
	AuthenticationReadResourceTypeApplication    AuthenticationReadResourceType = "Application"
	AuthenticationReadResourceTypeAuthentication AuthenticationReadResourceType = "Authentication"
	AuthenticationReadResourceTypeEndpoint       AuthenticationReadResourceType = "Endpoint"
	AuthenticationReadResourceTypeSource         AuthenticationReadResourceType = "Source"
)

// Defines values for BulkCreatePayloadAuthenticationsAuthtype.
const (
	BulkCreatePayloadAuthenticationsAuthtypeAccessKeySecretKey           BulkCreatePayloadAuthenticationsAuthtype = "access_key_secret_key"
	BulkCreatePayloadAuthenticationsAuthtypeApiTokenAccountId            BulkCreatePayloadAuthenticationsAuthtype = "api_token_account_id"
	BulkCreatePayloadAuthenticationsAuthtypeArn                          BulkCreatePayloadAuthenticationsAuthtype = "arn"
	BulkCreatePayloadAuthenticationsAuthtypeBitbucketAppPassword         BulkCreatePayloadAuthenticationsAuthtype = "bitbucket-app-password"
	BulkCreatePayloadAuthenticationsAuthtypeCloudMeterArn                BulkCreatePayloadAuthenticationsAuthtype = "cloud-meter-arn"
	BulkCreatePayloadAuthenticationsAuthtypeDockerAccessToken            BulkCreatePayloadAuthenticationsAuthtype = "docker-access-token"
	BulkCreatePayloadAuthenticationsAuthtypeGithubPersonalAccessToken    BulkCreatePayloadAuthenticationsAuthtype = "github-personal-access-token"
	BulkCreatePayloadAuthenticationsAuthtypeGitlabPersonalAccessToken    BulkCreatePayloadAuthenticationsAuthtype = "gitlab-personal-access-token"
	BulkCreatePayloadAuthenticationsAuthtypeLighthouseSubscriptionId     BulkCreatePayloadAuthenticationsAuthtype = "lighthouse_subscription_id"
	BulkCreatePayloadAuthenticationsAuthtypeMarketplaceToken             BulkCreatePayloadAuthenticationsAuthtype = "marketplace-token"
	BulkCreatePayloadAuthenticationsAuthtypeOcid                         BulkCreatePayloadAuthenticationsAuthtype = "ocid"
	BulkCreatePayloadAuthenticationsAuthtypeProjectIdServiceAccountJson  BulkCreatePayloadAuthenticationsAuthtype = "project_id_service_account_json"
	BulkCreatePayloadAuthenticationsAuthtypeQuayEncryptedPassword        BulkCreatePayloadAuthenticationsAuthtype = "quay-encrypted-password"
	BulkCreatePayloadAuthenticationsAuthtypeReceptorNode                 BulkCreatePayloadAuthenticationsAuthtype = "receptor_node"
	BulkCreatePayloadAuthenticationsAuthtypeTenantIdClientIdClientSecret BulkCreatePayloadAuthenticationsAuthtype = "tenant_id_client_id_client_secret"
	BulkCreatePayloadAuthenticationsAuthtypeToken                        BulkCreatePayloadAuthenticationsAuthtype = "token"
	BulkCreatePayloadAuthenticationsAuthtypeUsernamePassword             BulkCreatePayloadAuthenticationsAuthtype = "username_password"
)

// Defines values for BulkCreatePayloadAuthenticationsResourceType.
const (
	BulkCreatePayloadAuthenticationsResourceTypeApplication BulkCreatePayloadAuthenticationsResourceType = "application"
	BulkCreatePayloadAuthenticationsResourceTypeEndpoint    BulkCreatePayloadAuthenticationsResourceType = "endpoint"
	BulkCreatePayloadAuthenticationsResourceTypeSource      BulkCreatePayloadAuthenticationsResourceType = "source"
)

// Defines values for BulkCreatePayloadSourcesSourceTypeName.
const (
	BulkCreatePayloadSourcesSourceTypeNameAmazon                     BulkCreatePayloadSourcesSourceTypeName = "amazon"
	BulkCreatePayloadSourcesSourceTypeNameAzure                      BulkCreatePayloadSourcesSourceTypeName = "azure"
	BulkCreatePayloadSourcesSourceTypeNameBitbucket                  BulkCreatePayloadSourcesSourceTypeName = "bitbucket"
	BulkCreatePayloadSourcesSourceTypeNameDockerhub                  BulkCreatePayloadSourcesSourceTypeName = "dockerhub"
	BulkCreatePayloadSourcesSourceTypeNameGithub                     BulkCreatePayloadSourcesSourceTypeName = "github"
	BulkCreatePayloadSourcesSourceTypeNameGitlab                     BulkCreatePayloadSourcesSourceTypeName = "gitlab"
	BulkCreatePayloadSourcesSourceTypeNameGoogle                     BulkCreatePayloadSourcesSourceTypeName = "google"
	BulkCreatePayloadSourcesSourceTypeNameIbm                        BulkCreatePayloadSourcesSourceTypeName = "ibm"
	BulkCreatePayloadSourcesSourceTypeNameOpenshift                  BulkCreatePayloadSourcesSourceTypeName = "openshift"
	BulkCreatePayloadSourcesSourceTypeNameOracleCloudInfraestructure BulkCreatePayloadSourcesSourceTypeName = "oracle-cloud-infraestructure"
	BulkCreatePayloadSourcesSourceTypeNameQuay                       BulkCreatePayloadSourcesSourceTypeName = "quay"
	BulkCreatePayloadSourcesSourceTypeNameRhMarketplace              BulkCreatePayloadSourcesSourceTypeName = "rh-marketplace"
	BulkCreatePayloadSourcesSourceTypeNameSatellite                  BulkCreatePayloadSourcesSourceTypeName = "satellite"
)

// Defines values for EndpointAvailabilityStatus.
const (
	EndpointAvailabilityStatusAvailable   EndpointAvailabilityStatus = "available"
	EndpointAvailabilityStatusEmpty       EndpointAvailabilityStatus = ""
	EndpointAvailabilityStatusUnavailable EndpointAvailabilityStatus = "unavailable"
)

// Defines values for EndpointReadAvailabilityStatus.
const (
	EndpointReadAvailabilityStatusAvailable   EndpointReadAvailabilityStatus = "available"
	EndpointReadAvailabilityStatusEmpty       EndpointReadAvailabilityStatus = ""
	EndpointReadAvailabilityStatusUnavailable EndpointReadAvailabilityStatus = "unavailable"
)

// Defines values for RhcConnectionReadAvailabilityStatus.
const (
	RhcConnectionReadAvailabilityStatusAvailable          RhcConnectionReadAvailabilityStatus = "available"
	RhcConnectionReadAvailabilityStatusInProgress         RhcConnectionReadAvailabilityStatus = "in_progress"
	RhcConnectionReadAvailabilityStatusPartiallyAvailable RhcConnectionReadAvailabilityStatus = "partially_available"
	RhcConnectionReadAvailabilityStatusUnavailable        RhcConnectionReadAvailabilityStatus = "unavailable"
)

// Defines values for SourceAppCreationWorkflow.
const (
	SourceAppCreationWorkflowAccountAuthorization SourceAppCreationWorkflow = "account_authorization"
	SourceAppCreationWorkflowManualConfiguration  SourceAppCreationWorkflow = "manual_configuration"
)

// Defines values for SourceAvailabilityStatus.
const (
	SourceAvailabilityStatusAvailable          SourceAvailabilityStatus = "available"
	SourceAvailabilityStatusInProgress         SourceAvailabilityStatus = "in_progress"
	SourceAvailabilityStatusPartiallyAvailable SourceAvailabilityStatus = "partially_available"
	SourceAvailabilityStatusUnavailable        SourceAvailabilityStatus = "unavailable"
)

// Defines values for SourceCreateAppCreationWorkflow.
const (
	SourceCreateAppCreationWorkflowAccountAuthorization SourceCreateAppCreationWorkflow = "account_authorization"
	SourceCreateAppCreationWorkflowManualConfiguration  SourceCreateAppCreationWorkflow = "manual_configuration"
)

// Defines values for SourceCreateAvailabilityStatus.
const (
	SourceCreateAvailabilityStatusAvailable          SourceCreateAvailabilityStatus = "available"
	SourceCreateAvailabilityStatusInProgress         SourceCreateAvailabilityStatus = "in_progress"
	SourceCreateAvailabilityStatusPartiallyAvailable SourceCreateAvailabilityStatus = "partially_available"
	SourceCreateAvailabilityStatusUnavailable        SourceCreateAvailabilityStatus = "unavailable"
)

// Defines values for SourceEditAvailabilityStatus.
const (
	SourceEditAvailabilityStatusAvailable          SourceEditAvailabilityStatus = "available"
	SourceEditAvailabilityStatusInProgress         SourceEditAvailabilityStatus = "in_progress"
	SourceEditAvailabilityStatusPartiallyAvailable SourceEditAvailabilityStatus = "partially_available"
	SourceEditAvailabilityStatusUnavailable        SourceEditAvailabilityStatus = "unavailable"
)

// Application defines model for Application.
type Application struct {
	// ID of the resource
	ApplicationTypeId *ID `json:"application_type_id,omitempty"`

	// The availability status of the application
	AvailabilityStatus *ApplicationAvailabilityStatus `json:"availability_status,omitempty"`

	// The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// The timestamp of the creation of the application
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Any extra information you want stored for the application, in JSON format
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// ID of the resource
	Id *ID `json:"id,omitempty"`

	// The timestamp for when the application was last available at.
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// Timestamp of the last time the availability was checked for the application
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// The timestamp for when the application was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// ID of the resource
	SourceId *ID `json:"source_id,omitempty"`

	// The timestamp of the last time this application got updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// The availability status of the application
type ApplicationAvailabilityStatus string

// ApplicationType defines model for ApplicationType.
type ApplicationType struct {
	// The timestamp of the creation of the application type
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The dependent applications of this application type
	DependentApplications *map[string]interface{} `json:"dependent_applications,omitempty"`

	// The display name for the application type
	DisplayName *string `json:"display_name,omitempty"`

	// ID of the resource
	Id *ID `json:"id,omitempty"`

	// The name for the application type
	Name *string `json:"name,omitempty"`

	// The supported authentication types the applications of this type support
	SupportedAuthenticationTypes *map[string]interface{} `json:"supported_authentication_types,omitempty"`

	// The supported source types the applications of this type support
	SupportedSourceTypes *[]string `json:"supported_source_types,omitempty"`

	// The timestamp of the last time this application type got updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ApplicationTypesCollection defines model for ApplicationTypesCollection.
type ApplicationTypesCollection struct {
	Data  *[]ApplicationType  `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// ApplicationsCollection defines model for ApplicationsCollection.
type ApplicationsCollection struct {
	Data  *[]Application      `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// Expected payload to create an Authentication
type AuthenticationCreate struct {
	// The type of the authentication
	Authtype *interface{} `json:"authtype,omitempty"`

	// The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Any extra information the authentication may have
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// The authentication's name
	Name *string `json:"name,omitempty"`

	// The password for the authentication
	Password *string `json:"password,omitempty"`

	// ID of the resource. Not "readonly", since it might be used for create/update payloads
	ResourceId *IDW `json:"resource_id,omitempty"`

	// The type of the resource this authentication belongs to
	ResourceType *AuthenticationCreateResourceType `json:"resource_type,omitempty"`

	// The username for the authentication
	Username *string `json:"username,omitempty"`
}

// The type of the resource this authentication belongs to
type AuthenticationCreateResourceType string

// Authentication object
type AuthenticationRead struct {
	// The type of the authentication
	Authtype *interface{} `json:"authtype,omitempty"`

	// The availability status of the authentication
	AvailabilityStatus *interface{} `json:"availability_status,omitempty"`

	// The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Any extra information the authentication may have
	Extra *struct {
		Azure *struct {
			TenantId *string `json:"tenant_id,omitempty"`
		} `json:"azure,omitempty"`

		// If the authentication is of the "marketplace-token" type, then this key will contain an unexpired token for the API key that the authentication stores.
		Marketplace *struct {
			// The authorization token
			AccessToken *string `json:"access_token,omitempty"`

			// The Unix timestamp for the expiration of the token
			Expiration *float32 `json:"expiration,omitempty"`
		} `json:"marketplace,omitempty"`
	} `json:"extra,omitempty"`

	// ID of the resource
	Id *ID `json:"id,omitempty"`

	// The authentication's name
	Name *string `json:"name,omitempty"`

	// ID of the resource
	ResourceId *ID `json:"resource_id,omitempty"`

	// The type of the resource this authentication belongs to
	ResourceType *AuthenticationReadResourceType `json:"resource_type,omitempty"`

	// The username for the authentication
	Username *string `json:"username,omitempty"`
}

// The type of the resource this authentication belongs to
type AuthenticationReadResourceType string

// AuthenticationsCollection defines model for AuthenticationsCollection.
type AuthenticationsCollection struct {
	Data  *[]AuthenticationRead `json:"data,omitempty"`
	Links *CollectionLinks      `json:"links,omitempty"`
	Meta  *CollectionMetadata   `json:"meta,omitempty"`
}

// BulkCreatePayload defines model for BulkCreatePayload.
type BulkCreatePayload struct {
	// Array of application objects to create. The operation looks up the parent Source by the `source_name` attribute so the `source_name` must match one of the `source` names in the payload. You can specify the application type by using either the `application_type_name` or the `application_type_id`.
	Applications *[]struct {
		// The ID of the application type
		ApplicationTypeId *string `json:"application_type_id,omitempty"`

		// The name of the application type
		ApplicationTypeName *string `json:"application_type_name,omitempty"`

		// Any extra information you would like to store in JSON format
		Extra *map[string]interface{} `json:"extra,omitempty"`

		// The ID of the soruce this application will be attached to
		SourceId *string `json:"source_id,omitempty"`

		// The name of the source this application will be attached to
		SourceName string `json:"source_name"`
	} `json:"applications,omitempty"`

	// Array of authentications to create. `resource_type` tells the action where to look for the parent, must be either application, endpoint or source.
	// If the parent is a source, it looks up by name. If the parent is an endpoint, it looks up via host so the hostname must match. If the parent is an application, it looks up via application type so the value must match the application type which matches.
	Authentications *[]struct {
		// The type of the authentication. You can find this by listing the source types or the application types
		Authtype *BulkCreatePayloadAuthenticationsAuthtype `json:"authtype,omitempty"`

		// Any extra information you would like to store in JSON format
		Extra *map[string]interface{} `json:"extra,omitempty"`

		// The password of the authentication
		Password *string `json:"password,omitempty"`

		// The name of the resource this authentication relates to
		ResourceName *string `json:"resource_name,omitempty"`

		// The type of the resource this authentication relates to
		ResourceType *BulkCreatePayloadAuthenticationsResourceType `json:"resource_type,omitempty"`

		// The username of the authentication
		Username *string `json:"username,omitempty"`
	} `json:"authentications,omitempty"`

	// Array of endpoint objects to create. The operation looks up the parent source by the `source_name` attribute so the `source_name` must match one of the `source`'s names in the payload.
	Endpoints *[]struct {
		// URI host component of the endpoint.
		Host *string `json:"host,omitempty"`

		// URI path component of the endpoint.
		Path *string `json:"path,omitempty"`

		// URI port component of the endpoint.
		Port *int `json:"port,omitempty"`

		// URI scheme component of the endpoint.
		Scheme *string `json:"scheme,omitempty"`

		// The name of the source this endpoint will be attached to
		SourceName string `json:"source_name"`

		// Should the SSL certificate be verified?
		VerifySsl *bool `json:"verify_ssl,omitempty"`
	} `json:"endpoints,omitempty"`

	// Array of source objects to create
	Sources *[]struct {
		// The name of the source
		Name string `json:"name"`

		// The type of the source that will be created
		SourceTypeName BulkCreatePayloadSourcesSourceTypeName `json:"source_type_name"`
	} `json:"sources,omitempty"`
}

// The type of the authentication. You can find this by listing the source types or the application types
type BulkCreatePayloadAuthenticationsAuthtype string

// The type of the resource this authentication relates to
type BulkCreatePayloadAuthenticationsResourceType string

// The type of the source that will be created
type BulkCreatePayloadSourcesSourceTypeName string

// CollectionLinks defines model for CollectionLinks.
type CollectionLinks struct {
	// The link to the first object of the list
	First *string `json:"first,omitempty"`

	// The link to the last object of the list
	Last *string `json:"last,omitempty"`

	// The link to the next page of objects
	Next *string `json:"next,omitempty"`

	// The link to the previous page of objects
	Prev *string `json:"prev,omitempty"`
}

// CollectionMetadata defines model for CollectionMetadata.
type CollectionMetadata struct {
	// The total amount of objects in the database
	Count *int `json:"count,omitempty"`

	// The limit of objects that was applied to the object list
	Limit *int `json:"limit,omitempty"`

	// The offset that was applied to the list
	Offset *int `json:"offset,omitempty"`
}

// Representation of an endpoint object
type Endpoint struct {
	// The availability status of the endpoint.
	AvailabilityStatus *EndpointAvailabilityStatus `json:"availability_status,omitempty"`

	// The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Optional X.509 Certificate Authority
	CertificateAuthority *string `json:"certificate_authority,omitempty"`

	// The timestamp for when the endpoint was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Mark endpoint as the default endpoint? Each source can only have one default endpoint. It gets set to true by default if the given source has no endpoints.
	Default *bool `json:"default,omitempty"`

	// URI host component of the endpoint.
	Host *string `json:"host,omitempty"`

	// ID of the resource
	Id *ID `json:"id,omitempty"`

	// Timestamp of the last time the connection was available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// Timestamp of the last time the availability was checked for the connection
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// URI path component of the endpoint.
	Path *string `json:"path,omitempty"`

	// The timestamp for when the endpoint was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// URI port component of the endpoint.
	Port *int `json:"port,omitempty"`

	// Identifier of a receptor node.
	ReceptorNode *string `json:"receptor_node,omitempty"`

	// The role of the endpoint. It must be unique among the source's endpoints.
	Role *string `json:"role,omitempty"`

	// The scheme of the protocol.
	Scheme *string `json:"scheme,omitempty"`

	// ID of the resource
	SourceId *ID `json:"source_id,omitempty"`

	// The timestamp for when the source was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Should the SSL certificate be verified?
	VerifySsl *bool `json:"verify_ssl,omitempty"`
}

// The availability status of the endpoint.
type EndpointAvailabilityStatus string

// Endpoint object
type EndpointRead struct {
	// The availability status of the endpoint.
	AvailabilityStatus *EndpointReadAvailabilityStatus `json:"availability_status,omitempty"`

	// The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Optional X.509 Certificate Authority
	CertificateAuthority *string `json:"certificate_authority,omitempty"`

	// The timestamp for when the endpoint was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Mark endpoint as the default endpoint? Each source can only have one default endpoint. It gets set to true by default if the given source has no endpoints.
	Default *bool `json:"default,omitempty"`

	// URI host component of the endpoint.
	Host *string `json:"host,omitempty"`

	// ID of the resource
	Id *ID `json:"id,omitempty"`

	// Timestamp of the last time the connection was available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// Timestamp of the last time the availability was checked for the connection
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// URI path component of the endpoint.
	Path *string `json:"path,omitempty"`

	// The timestamp for when the endpoint was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// URI port component of the endpoint.
	Port *int `json:"port,omitempty"`

	// Identifier of a receptor node.
	ReceptorNode *string `json:"receptor_node,omitempty"`

	// The role of the endpoint. It must be unique among the source's endpoints.
	Role *string `json:"role,omitempty"`

	// The scheme of the protocol.
	Scheme *string `json:"scheme,omitempty"`

	// ID of the resource
	SourceId *ID `json:"source_id,omitempty"`

	// The timestamp for when the source was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Should the SSL certificate be verified?
	VerifySsl *bool `json:"verify_ssl,omitempty"`
}

// The availability status of the endpoint.
type EndpointReadAvailabilityStatus string

// EndpointsCollection defines model for EndpointsCollection.
type EndpointsCollection struct {
	Data  *[]EndpointRead     `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// Error structure for the "Bad Request" responses
type ErrorBadRequest struct {
	Errors *[]struct {
		// Detail of the error
		Detail *string `json:"detail,omitempty"`

		// Status of the response
		Status *string `json:"status,omitempty"`
	} `json:"errors,omitempty"`
}

// Error structure for the "Not Found" responses
type ErrorNotFound struct {
	Errors *[]struct {
		// Detail of the error
		Detail *string `json:"detail,omitempty"`

		// Status of the response
		Status *string `json:"status,omitempty"`
	} `json:"errors,omitempty"`
}

// ID of the resource
type ID = string

// ID of the resource. Not "readonly", since it might be used for create/update payloads
type IDW = string

// Collection of Red Hat Connector Connections along with the metadata
type RhcConnectionCollection struct {
	Data  *[]RhcConnectionRead `json:"data,omitempty"`
	Links *CollectionLinks     `json:"links,omitempty"`
	Meta  *CollectionMetadata  `json:"meta,omitempty"`
}

// RhcConnectionRead defines model for RhcConnectionRead.
type RhcConnectionRead struct {
	// The availability status of the connection
	AvailabilityStatus *RhcConnectionReadAvailabilityStatus `json:"availability_status,omitempty"`

	// The received error message when polling for the availability status
	AvailabilityStatusError *string `json:"availability_status_error,omitempty"`

	// Extra data in JSON format
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// ID of the resource
	Id *ID `json:"id,omitempty"`

	// Timestamp of the last time the connection was available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// Timestamp of the last time the availability was checked for the connection
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// The UUID of the connection
	RhcId *string `json:"rhc_id,omitempty"`

	// The connection's related sources
	SourceIds *[]ID `json:"source_ids,omitempty"`
}

// The availability status of the connection
type RhcConnectionReadAvailabilityStatus string

// Source defines model for Source.
type Source struct {
	AppCreationWorkflow *SourceAppCreationWorkflow `json:"app_creation_workflow,omitempty"`

	// The availability status of the source
	AvailabilityStatus *SourceAvailabilityStatus `json:"availability_status,omitempty"`

	// The timestamp for when the source was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ID of the resource
	Id *ID `json:"id,omitempty"`

	// Was the source imported?
	Imported *string `json:"imported,omitempty"`

	// The timestamp for when the source was last available at.
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// The timestamp for when the source was last checked at for the availability status.
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// The name of the source
	Name *string `json:"name,omitempty"`

	// The timestamp for when the source was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`

	// The external referece or ID for the source
	SourceRef *string `json:"source_ref,omitempty"`

	// ID of the resource
	SourceTypeId *ID `json:"source_type_id,omitempty"`

	// Unique ID of the inventory source installation
	Uid *string `json:"uid,omitempty"`

	// The timestamp for when the source was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// The version of the source
	Version *string `json:"version,omitempty"`
}

// SourceAppCreationWorkflow defines model for Source.AppCreationWorkflow.
type SourceAppCreationWorkflow string

// The availability status of the source
type SourceAvailabilityStatus string

// The payload that the back end accepts when creating a source
type SourceCreate struct {
	// The way the source is going to be created: manually, or using superkey?
	AppCreationWorkflow *SourceCreateAppCreationWorkflow `json:"app_creation_workflow,omitempty"`

	// The availability status of the source
	AvailabilityStatus *SourceCreateAvailabilityStatus `json:"availability_status,omitempty"`

	// Was the source imported?
	Imported *string `json:"imported,omitempty"`

	// The name of the source
	Name *string `json:"name,omitempty"`

	// The external referece or ID for the source
	SourceRef *string `json:"source_ref,omitempty"`

	// The ID of the source type
	SourceTypeId *string `json:"source_type_id,omitempty"`

	// Unique ID of the inventory source installation
	Uid *string `json:"uid,omitempty"`

	// The version of the source
	Version *string `json:"version,omitempty"`
}

// The way the source is going to be created: manually, or using superkey?
type SourceCreateAppCreationWorkflow string

// The availability status of the source
type SourceCreateAvailabilityStatus string

// The payload that the back end accepts when editing a source
type SourceEdit struct {
	// The availability status of the source
	AvailabilityStatus *SourceEditAvailabilityStatus `json:"availability_status,omitempty"`

	// Was the source imported?
	Imported *string `json:"imported,omitempty"`

	// The timestamp of the last time the source was seen as available
	LastAvailableAt *time.Time `json:"last_available_at,omitempty"`

	// The timestamp of the last time the source was checked for the availability status
	LastCheckedAt *time.Time `json:"last_checked_at,omitempty"`

	// The name of the source
	Name *string `json:"name,omitempty"`

	// The external referece or ID for the source
	SourceRef *string `json:"source_ref,omitempty"`

	// The version of the source
	Version *string `json:"version,omitempty"`
}

// The availability status of the source
type SourceEditAvailabilityStatus string

// An array containing source objects
type SourcesCollection struct {
	Data  *[]Source           `json:"data,omitempty"`
	Links *CollectionLinks    `json:"links,omitempty"`
	Meta  *CollectionMetadata `json:"meta,omitempty"`
}

// QueryFilter defines model for QueryFilter.
type QueryFilter = string

// QueryLimit defines model for QueryLimit.
type QueryLimit = int

// QueryOffset defines model for QueryOffset.
type QueryOffset = int

// QuerySortBy defines model for QuerySortBy.
type QuerySortBy = string

// Error structure for the "Bad Request" responses
type BadRequest = ErrorBadRequest

// Error structure for the "Not Found" responses
type NotFound = ErrorNotFound

// BulkCreateJSONBody defines parameters for BulkCreate.
type BulkCreateJSONBody = BulkCreatePayload

// ListSourcesParams defines parameters for ListSources.
type ListSourcesParams struct {
	// The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// CreateSourceJSONBody defines parameters for CreateSource.
type CreateSourceJSONBody = SourceCreate

// UpdateSourceJSONBody defines parameters for UpdateSource.
type UpdateSourceJSONBody = SourceEdit

// ListSourceApplicationTypesParams defines parameters for ListSourceApplicationTypes.
type ListSourceApplicationTypesParams struct {
	// The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourceApplicationsParams defines parameters for ListSourceApplications.
type ListSourceApplicationsParams struct {
	// The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourceAuthenticationsParams defines parameters for ListSourceAuthentications.
type ListSourceAuthenticationsParams struct {
	// The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// ListSourceEndpointsParams defines parameters for ListSourceEndpoints.
type ListSourceEndpointsParams struct {
	// The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// GetSourcesRhcConnectionParams defines parameters for GetSourcesRhcConnection.
type GetSourcesRhcConnectionParams struct {
	// The numbers of items to return per page.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// The number of items to skip before starting to collect the result set.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for querying collections. The format of the filters is as follows: `filter[subresource][field][operation]="value"`.
	Filter *QueryFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// The list of attribute and order to sort the result set by.
	SortBy *QuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`
}

// BulkCreateJSONRequestBody defines body for BulkCreate for application/json ContentType.
type BulkCreateJSONRequestBody = BulkCreateJSONBody

// CreateSourceJSONRequestBody defines body for CreateSource for application/json ContentType.
type CreateSourceJSONRequestBody = CreateSourceJSONBody

// UpdateSourceJSONRequestBody defines body for UpdateSource for application/json ContentType.
type UpdateSourceJSONRequestBody = UpdateSourceJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BulkCreate request with any body
	BulkCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreate(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSources request
	ListSources(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSource request with any body
	CreateSourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSource(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSource request
	DeleteSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowSource request
	ShowSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSource request with any body
	UpdateSourceWithBody(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSource(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceApplicationTypes request
	ListSourceApplicationTypes(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceApplications request
	ListSourceApplications(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceAuthentications request
	ListSourceAuthentications(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckAvailabilitySource request
	CheckAvailabilitySource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSourceEndpoints request
	ListSourceEndpoints(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PauseSource request
	PauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSourcesRhcConnection request
	GetSourcesRhcConnection(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnpauseSource request
	UnpauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BulkCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreate(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSources(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSource(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSourceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSourceWithBody(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSource(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSourceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceApplicationTypes(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceApplicationTypesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceApplications(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceApplicationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceAuthentications(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceAuthenticationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAvailabilitySource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAvailabilitySourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSourceEndpoints(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSourceEndpointsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPauseSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSourcesRhcConnection(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourcesRhcConnectionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpauseSource(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpauseSourceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBulkCreateRequest calls the generic BulkCreate builder with application/json body
func NewBulkCreateRequest(server string, body BulkCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateRequestWithBody generates requests for BulkCreate with any type of body
func NewBulkCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bulk_create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSourcesRequest generates requests for ListSources
func NewListSourcesRequest(server string, params *ListSourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSourceRequest calls the generic CreateSource builder with application/json body
func NewCreateSourceRequest(server string, body CreateSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSourceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSourceRequestWithBody generates requests for CreateSource with any type of body
func NewCreateSourceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSourceRequest generates requests for DeleteSource
func NewDeleteSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowSourceRequest generates requests for ShowSource
func NewShowSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSourceRequest calls the generic UpdateSource builder with application/json body
func NewUpdateSourceRequest(server string, id ID, body UpdateSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSourceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSourceRequestWithBody generates requests for UpdateSource with any type of body
func NewUpdateSourceRequestWithBody(server string, id ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSourceApplicationTypesRequest generates requests for ListSourceApplicationTypes
func NewListSourceApplicationTypesRequest(server string, id ID, params *ListSourceApplicationTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/application_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourceApplicationsRequest generates requests for ListSourceApplications
func NewListSourceApplicationsRequest(server string, id ID, params *ListSourceApplicationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/applications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourceAuthenticationsRequest generates requests for ListSourceAuthentications
func NewListSourceAuthenticationsRequest(server string, id ID, params *ListSourceAuthenticationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/authentications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckAvailabilitySourceRequest generates requests for CheckAvailabilitySource
func NewCheckAvailabilitySourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/check_availability", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSourceEndpointsRequest generates requests for ListSourceEndpoints
func NewListSourceEndpointsRequest(server string, id ID, params *ListSourceEndpointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPauseSourceRequest generates requests for PauseSource
func NewPauseSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourcesRhcConnectionRequest generates requests for GetSourcesRhcConnection
func NewGetSourcesRhcConnectionRequest(server string, id ID, params *GetSourcesRhcConnectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/rhc_connections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnpauseSourceRequest generates requests for UnpauseSource
func NewUnpauseSourceRequest(server string, id ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sources/%s/unpause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BulkCreate request with any body
	BulkCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error)

	BulkCreateWithResponse(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error)

	// ListSources request
	ListSourcesWithResponse(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*ListSourcesResponse, error)

	// CreateSource request with any body
	CreateSourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error)

	CreateSourceWithResponse(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error)

	// DeleteSource request
	DeleteSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error)

	// ShowSource request
	ShowSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowSourceResponse, error)

	// UpdateSource request with any body
	UpdateSourceWithBodyWithResponse(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	UpdateSourceWithResponse(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error)

	// ListSourceApplicationTypes request
	ListSourceApplicationTypesWithResponse(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationTypesResponse, error)

	// ListSourceApplications request
	ListSourceApplicationsWithResponse(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationsResponse, error)

	// ListSourceAuthentications request
	ListSourceAuthenticationsWithResponse(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*ListSourceAuthenticationsResponse, error)

	// CheckAvailabilitySource request
	CheckAvailabilitySourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*CheckAvailabilitySourceResponse, error)

	// ListSourceEndpoints request
	ListSourceEndpointsWithResponse(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*ListSourceEndpointsResponse, error)

	// PauseSource request
	PauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*PauseSourceResponse, error)

	// GetSourcesRhcConnection request
	GetSourcesRhcConnectionWithResponse(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*GetSourcesRhcConnectionResponse, error)

	// UnpauseSource request
	UnpauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*UnpauseSourceResponse, error)
}

type BulkCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BulkCreateResponse
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r BulkCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SourcesCollection
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r ListSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Source
	JSON400      *ErrorBadRequest
}

// Status returns HTTPResponse.Status
func (r CreateSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r DeleteSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ShowSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Source
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r UpdateSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceApplicationTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationTypesCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceApplicationTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceApplicationTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceApplicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationsCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceApplicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceApplicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceAuthenticationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationsCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceAuthenticationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceAuthenticationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckAvailabilitySourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r CheckAvailabilitySourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAvailabilitySourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSourceEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointsCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r ListSourceEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PauseSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r PauseSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PauseSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourcesRhcConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RhcConnectionCollection
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r GetSourcesRhcConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourcesRhcConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpauseSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBadRequest
	JSON404      *ErrorNotFound
}

// Status returns HTTPResponse.Status
func (r UnpauseSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpauseSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BulkCreateWithBodyWithResponse request with arbitrary body returning *BulkCreateResponse
func (c *ClientWithResponses) BulkCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error) {
	rsp, err := c.BulkCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateWithResponse(ctx context.Context, body BulkCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateResponse, error) {
	rsp, err := c.BulkCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateResponse(rsp)
}

// ListSourcesWithResponse request returning *ListSourcesResponse
func (c *ClientWithResponses) ListSourcesWithResponse(ctx context.Context, params *ListSourcesParams, reqEditors ...RequestEditorFn) (*ListSourcesResponse, error) {
	rsp, err := c.ListSources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourcesResponse(rsp)
}

// CreateSourceWithBodyWithResponse request with arbitrary body returning *CreateSourceResponse
func (c *ClientWithResponses) CreateSourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error) {
	rsp, err := c.CreateSourceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceResponse(rsp)
}

func (c *ClientWithResponses) CreateSourceWithResponse(ctx context.Context, body CreateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSourceResponse, error) {
	rsp, err := c.CreateSource(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSourceResponse(rsp)
}

// DeleteSourceWithResponse request returning *DeleteSourceResponse
func (c *ClientWithResponses) DeleteSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*DeleteSourceResponse, error) {
	rsp, err := c.DeleteSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSourceResponse(rsp)
}

// ShowSourceWithResponse request returning *ShowSourceResponse
func (c *ClientWithResponses) ShowSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*ShowSourceResponse, error) {
	rsp, err := c.ShowSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowSourceResponse(rsp)
}

// UpdateSourceWithBodyWithResponse request with arbitrary body returning *UpdateSourceResponse
func (c *ClientWithResponses) UpdateSourceWithBodyWithResponse(ctx context.Context, id ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSourceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSourceWithResponse(ctx context.Context, id ID, body UpdateSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSourceResponse, error) {
	rsp, err := c.UpdateSource(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSourceResponse(rsp)
}

// ListSourceApplicationTypesWithResponse request returning *ListSourceApplicationTypesResponse
func (c *ClientWithResponses) ListSourceApplicationTypesWithResponse(ctx context.Context, id ID, params *ListSourceApplicationTypesParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationTypesResponse, error) {
	rsp, err := c.ListSourceApplicationTypes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceApplicationTypesResponse(rsp)
}

// ListSourceApplicationsWithResponse request returning *ListSourceApplicationsResponse
func (c *ClientWithResponses) ListSourceApplicationsWithResponse(ctx context.Context, id ID, params *ListSourceApplicationsParams, reqEditors ...RequestEditorFn) (*ListSourceApplicationsResponse, error) {
	rsp, err := c.ListSourceApplications(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceApplicationsResponse(rsp)
}

// ListSourceAuthenticationsWithResponse request returning *ListSourceAuthenticationsResponse
func (c *ClientWithResponses) ListSourceAuthenticationsWithResponse(ctx context.Context, id ID, params *ListSourceAuthenticationsParams, reqEditors ...RequestEditorFn) (*ListSourceAuthenticationsResponse, error) {
	rsp, err := c.ListSourceAuthentications(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceAuthenticationsResponse(rsp)
}

// CheckAvailabilitySourceWithResponse request returning *CheckAvailabilitySourceResponse
func (c *ClientWithResponses) CheckAvailabilitySourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*CheckAvailabilitySourceResponse, error) {
	rsp, err := c.CheckAvailabilitySource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAvailabilitySourceResponse(rsp)
}

// ListSourceEndpointsWithResponse request returning *ListSourceEndpointsResponse
func (c *ClientWithResponses) ListSourceEndpointsWithResponse(ctx context.Context, id ID, params *ListSourceEndpointsParams, reqEditors ...RequestEditorFn) (*ListSourceEndpointsResponse, error) {
	rsp, err := c.ListSourceEndpoints(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSourceEndpointsResponse(rsp)
}

// PauseSourceWithResponse request returning *PauseSourceResponse
func (c *ClientWithResponses) PauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*PauseSourceResponse, error) {
	rsp, err := c.PauseSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePauseSourceResponse(rsp)
}

// GetSourcesRhcConnectionWithResponse request returning *GetSourcesRhcConnectionResponse
func (c *ClientWithResponses) GetSourcesRhcConnectionWithResponse(ctx context.Context, id ID, params *GetSourcesRhcConnectionParams, reqEditors ...RequestEditorFn) (*GetSourcesRhcConnectionResponse, error) {
	rsp, err := c.GetSourcesRhcConnection(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourcesRhcConnectionResponse(rsp)
}

// UnpauseSourceWithResponse request returning *UnpauseSourceResponse
func (c *ClientWithResponses) UnpauseSourceWithResponse(ctx context.Context, id ID, reqEditors ...RequestEditorFn) (*UnpauseSourceResponse, error) {
	rsp, err := c.UnpauseSource(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpauseSourceResponse(rsp)
}

// ParseBulkCreateResponse parses an HTTP response from a BulkCreateWithResponse call
func ParseBulkCreateResponse(rsp *http.Response) (*BulkCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BulkCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListSourcesResponse parses an HTTP response from a ListSourcesWithResponse call
func ParseListSourcesResponse(rsp *http.Response) (*ListSourcesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SourcesCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateSourceResponse parses an HTTP response from a CreateSourceWithResponse call
func ParseCreateSourceResponse(rsp *http.Response) (*CreateSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteSourceResponse parses an HTTP response from a DeleteSourceWithResponse call
func ParseDeleteSourceResponse(rsp *http.Response) (*DeleteSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseShowSourceResponse parses an HTTP response from a ShowSourceWithResponse call
func ParseShowSourceResponse(rsp *http.Response) (*ShowSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSourceResponse parses an HTTP response from a UpdateSourceWithResponse call
func ParseUpdateSourceResponse(rsp *http.Response) (*UpdateSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Source
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceApplicationTypesResponse parses an HTTP response from a ListSourceApplicationTypesWithResponse call
func ParseListSourceApplicationTypesResponse(rsp *http.Response) (*ListSourceApplicationTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceApplicationTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationTypesCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceApplicationsResponse parses an HTTP response from a ListSourceApplicationsWithResponse call
func ParseListSourceApplicationsResponse(rsp *http.Response) (*ListSourceApplicationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceApplicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceAuthenticationsResponse parses an HTTP response from a ListSourceAuthenticationsWithResponse call
func ParseListSourceAuthenticationsResponse(rsp *http.Response) (*ListSourceAuthenticationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceAuthenticationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCheckAvailabilitySourceResponse parses an HTTP response from a CheckAvailabilitySourceWithResponse call
func ParseCheckAvailabilitySourceResponse(rsp *http.Response) (*CheckAvailabilitySourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckAvailabilitySourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSourceEndpointsResponse parses an HTTP response from a ListSourceEndpointsWithResponse call
func ParseListSourceEndpointsResponse(rsp *http.Response) (*ListSourceEndpointsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSourceEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointsCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePauseSourceResponse parses an HTTP response from a PauseSourceWithResponse call
func ParsePauseSourceResponse(rsp *http.Response) (*PauseSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PauseSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSourcesRhcConnectionResponse parses an HTTP response from a GetSourcesRhcConnectionWithResponse call
func ParseGetSourcesRhcConnectionResponse(rsp *http.Response) (*GetSourcesRhcConnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourcesRhcConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RhcConnectionCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnpauseSourceResponse parses an HTTP response from a UnpauseSourceWithResponse call
func ParseUnpauseSourceResponse(rsp *http.Response) (*UnpauseSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpauseSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
