# Contributing to Provisioning

## Commit messages

Make sure your commit message follows this subject style:

        type: brief summary up to 70 characters or
        type(scope): brief summary up to 70 characters

Type must be one of the following:

* **build**: Changes that affect the build system
* **ci**: Changes to our CI configuration files and scripts
* **docs**: Documentation only changes
* **feat**: A new feature
* **fix**: A bug fix
* **perf**: A code change that improves performance
* **refactor**: A code change that neither fixes a bug nor adds a feature
* **chore**: A non-code change that does not fit to any category
* **test**: Adding missing tests or correcting existing tests
* **revert**: A commit revert

Scope is typically the most significant Go package that was changed, or the main component. Typical scopes:

* dao
* cache
* clients
* oapi
* readme
* changelog
* scripts

Or the scope can be [HMSPROV](https://issues.redhat.com/projects/HMSPROV) Jira issue.

For **feat** and **fix** types Jira issue is required.
Please use **feat(HMSPROV-XXX): subject**
or put the issue reference in commit body as `Fixes: HMSPROV-XXX` or `Refs: HMSPROV-XXX`

Use `make check-commits` to check commit message locally.

## Basic guidelines for code contributions

Here are few points before you start contributing:

* Binaries go into the `cmd/name` package.
* All code go into the `internal/` package.
* Binaries must not take any arguments.
* All configuration is done via `configs/local.yml` and can be overwritten by environment variables.
* Database models (structs) do belong into `internal/models`. Type names are named in singular form.
* Database DDL SQL goes into `internal/db/migrations` as SQL files. Table names are in plural form.
* Do not put any code logic into database models.
* All database operations (CRUD, eager loading) lives in `internal/dao` (Data Access Objects) with a common API interface.
* The actual implementation lives in `internal/dao/pgx` package, all operations are passed with Context and errors are wrapped.
* Database models must be not exposed directly into JSON API, use `internal/payloads` package to wrap them.
* Business logic (the actual code) does belong into `internal/services` package, each API call should have a dedicated file.
* HTTP routes go into `internal/routes` package.
* HTTP middleware go into `internal/middleware` package.
* Monitoring metrics are in `internal/metrics` package.
* Use the standard library context package for context operations. Context keys are defined in `internal/ctxval` as well as accessor functions.
* Database connection is at `internal/db`, HTTP service clients are in `internal/clients`.
* Do not introduce `utils` or `tools` common packages.
* Keep the line of sight (happy code path).
* Postgres version we currently use in production is v14+ so take advantage of all modern SQL features.
* Use `BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY` for primary keys. This allows us to use 1-100 in our seed data (see above).
* Use `TEXT` for string columns, do not apply any limits in the DB: https://wiki.postgresql.org/wiki/Don%27t_Do_This#Text_storage
* When modifying the API endpoints or types, please [update](https://github.com/RHEnVision/provisioning-backend/blob/main/docs/openapi.md) the openapi spec file as well

Keep security in mind: https://github.com/RedHatInsights/secure-coding-checklist

## Testing

All code logic has unit test coverage.
We test all logic in isolation
